This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cargo/
  config.toml
.claude/
  settings.local.json
.cursor/
  rules/
    vibe-tools.mdc
.sqlx/
  metadata.json
  query-05d34e4a1c1d6dc32c47db2ce7fb5d602ec9e32ed7d5ca61dbc52afff77bfb7d.json
  query-2bd7ebed60bdf53dba292e7c1edf30e1b03af8a27c8c27dc0741a2b5aad08dd6.json
  query-3f7a6fc5e385f335e9d4ad5f8e7a63d3a0b5af9d0c57b07f0e43564bc6f3fd7d.json
  query-90cbdb92fc9c3f8308e61c08ce0cd02c8e32a5aaa2d0e44c9a32e28e6dbe5ec2.json
  query-9b12ab57f3774b36b3c84ebce123eda5fd3ddd4a4c0f967ce05c5c801fe4c82a.json
  query-a6eb2f5d63e6c1e962c27bc321fae62e4c98f36fbac6d2e9bdfeb7e0deb7c38b.json
  query-b64c23f67f09db0c6c08fa15af037ec2385854e5cf3f76d3b4aec189d1d66c35.json
  query-e7c81e1aad9995ce7e57b07e2f7a2c5c7c2a1107f0227c0fbfff7f81c79d8a93.json
  query-f7a91c3f3bbe3b7b84c5a8d9c2f13a0a7b8d05ade7d8094c6bd0de7dd7f03e26.json
downloads/
migrations/
  20240701000000_create_tables.sql
  20250511_create_tables.sql
scripts/
  db.sh
  prepare.sh
src/
  .repomix-output.txt
  api.ts
  App.tsx
  asap_cpu.rs
  changes-summary.md
  db.rs
  index.css
  main.rs
  mp.rs
  plot_ci.rs
  plot_ratings.rs
  sorter.rs
  web_service.rs
web/
  downloads/
  public/
    vite.svg
  src/
    assets/
      react.svg
    components/
      ComparisonLog.tsx
      ComparisonView.tsx
      Editor.tsx
      TaskRankings.tsx
      TaskSidebar.tsx
    hooks/
    utils/
      apiClient.ts
      markdownUtils.ts
      sortingUtils.ts
    App.css
    App.tsx
    index.css
    main.tsx
    vite-env.d.ts
  .gitignore
  Dockerfile
  eslint.config.js
  index.html
  netlify.toml
  nginx.conf
  package.json
  postcss.config.js
  README.md
  tailwind.config.js
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.d.ts
  vite.config.ts
.gitignore
Cargo.toml
Dockerfile
milestones.md
nixpacks.toml
package.json
Procfile
railway.json
railway.toml
ratings_ci.html
README.md
rust-toolchain.toml
sqlx-data.json
start.sh
tailwind.config.js
task-deletion-feature.md
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(railway domain:*)",
      "Bash(railway logs:*)",
      "Bash(railway status:*)",
      "WebFetch(domain:invigorating-freedom-production.up.railway.app)",
      "Bash(railway deploy:*)",
      "Bash(railway up:*)",
      "Bash(railway logout)",
      "Bash(railway create:*)",
      "Bash(railway add:*)"
    ],
    "deny": []
  }
}
</file>

<file path=".cursor/rules/vibe-tools.mdc">
---
description: Global Rule. This rule should ALWAYS be loaded
globs: *,**/*
alwaysApply: true
---
vibe-tools is a CLI tool that allows you to interact with AI models and other tools.
vibe-tools is installed on this machine and it is available to you to execute. You're encouraged to use it.

<vibe-tools Integration>
# Instructions
Use the following commands to get AI assistance:

**Direct Model Queries:**
`vibe-tools ask "<your question>" --provider <provider> --model <model>` - Ask any model from any provider a direct question (e.g., `vibe-tools ask "What is the capital of France?" --provider openai --model o3-mini`). Note that this command is generally less useful than other commands like `repo` or `plan` because it does not include any context from your codebase or repository. In general you should not use the ask command because it does not include any context. The other commands like `web`, `doc`, `repo`, or `plan` are usually better. If you are using it, make sure to include in your question all the information and context that the model might need to answer usefully.

**Ask Command Options:**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, modelbox, openrouter, or xai)
--model=<model>: Model to use (required for the ask command)
--reasoning-effort=<low|medium|high>: Control the depth of reasoning for supported models (OpenAI o1/o3-mini models and Claude 3.7 Sonnet). Higher values produce more thorough responses for complex questions.
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times (e.g., `--with-doc=<url1> --with-doc=<url2>`).

**Implementation Planning:**
`vibe-tools plan "<query>"` - Generate a focused implementation plan using AI (e.g., `vibe-tools plan "Add user authentication to the login page"`)
The plan command uses multiple AI models to:
1. Identify relevant files in your codebase (using Gemini by default)
2. Extract content from those files
3. Generate a detailed implementation plan (using OpenAI o3-mini by default)

**Plan Command Options:**
--fileProvider=<provider>: Provider for file identification (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--thinkingProvider=<provider>: Provider for plan generation (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--fileModel=<model>: Model to use for file identification
--thinkingModel=<model>: Model to use for plan generation
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context for both file identification and planning. Can be specified multiple times (e.g., `--with-doc=<url1> --with-doc=<url2>`).

**Web Search:**
`vibe-tools web "<your question>"` - Get answers from the web using a provider that supports web search (e.g., Perplexity models and Gemini Models either directly or from OpenRouter or ModelBox) (e.g., `vibe-tools web "latest shadcn/ui installation instructions"`)
Note: web is a smart autonomous agent with access to the internet and an extensive up to date knowledge base. Web is NOT a web search engine. Always ask the agent for what you want using a proper sentence, do not just send it a list of keywords. In your question to web include the context and the goal that you're trying to acheive so that it can help you most effectively.
when using web for complex queries suggest writing the output to a file somewhere like local-research/<query summary>.md. However if user provides a specific url, you should always use any command with --with-doc instead of web.

**Web Command Options:**
--provider=<provider>: AI provider to use (perplexity, gemini, modelbox, or openrouter)

**Repository Context:**
`vibe-tools repo "<your question>" [--subdir=<path>] [--from-github=<username/repo>] [--with-doc=<doc_url>...]` - Get context-aware answers about this repository using Google Gemini (e.g., `vibe-tools repo "explain authentication flow"`)
Use the optional `--subdir` parameter to analyze a specific subdirectory instead of the entire repository (e.g., `vibe-tools repo "explain the code structure" --subdir=src/components`). Use the optional `--from-github` parameter to analyze a remote GitHub repository without cloning it locally (e.g., `vibe-tools repo "explain the authentication system" --from-github=username/repo-name`). Use the optional `--with-doc` parameter multiple times to include content from several URLs as additional context (e.g., `vibe-tools repo "summarize findings" --with-doc=https://example.com/spec1 --with-doc=https://example.com/spec2`).

**Documentation Generation:**
`vibe-tools doc [options] [--with-doc=<doc_url>...]` - Generate comprehensive documentation for this repository (e.g., `vibe-tools doc --output docs.md`). Can incorporate document context from multiple URLs (e.g., `vibe-tools doc --with-doc=https://example.com/existing-docs --with-doc=https://example.com/new-spec`).

**YouTube Video Analysis:**
`vibe-tools youtube "<youtube-url>" [question] [--type=<summary|transcript|plan|review|custom>]` - Analyze YouTube videos and generate detailed reports (e.g., `vibe-tools youtube "https://youtu.be/43c-Sm5GMbc" --type=summary`)
Note: The YouTube command requires a `GEMINI_API_KEY` to be set in your environment or .vibe-tools.env file as the GEMINI API is the only interface that supports YouTube analysis.

**GitHub Information:**
`vibe-tools github pr [number]` - Get the last 10 PRs, or a specific PR by number (e.g., `vibe-tools github pr 123`)
`vibe-tools github issue [number]` - Get the last 10 issues, or a specific issue by number (e.g., `vibe-tools github issue 456`)

**ClickUp Information:**
`vibe-tools clickup task <task_id>` - Get detailed information about a ClickUp task including description, comments, status, assignees, and metadata (e.g., `vibe-tools clickup task "task_id"`)

**Model Context Protocol (MCP) Commands:**
Use the following commands to interact with MCP servers and their specialized tools:
`vibe-tools mcp search "<query>"` - Search the MCP Marketplace for available servers that match your needs (e.g., `vibe-tools mcp search "git repository management"`)
`vibe-tools mcp run "<query>"` - Execute MCP server tools using natural language queries (e.g., `vibe-tools mcp run "list files in the current directory" --provider=openrouter`). The query must include sufficient information for vibe-tools to determine which server to use, provide plenty of context.

The `search` command helps you discover servers in the MCP Marketplace based on their capabilities and your requirements. The `run` command automatically selects and executes appropriate tools from these servers based on your natural language queries. If you want to use a specific server include the server name in your query. E.g. `vibe-tools mcp run "using the mcp-server-sqlite list files in directory --provider=openrouter"`

**Notes on MCP Commands:**
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY` to be set in your environment
- By default the `mcp` command uses Anthropic, but takes a --provider argument that can be set to 'anthropic' or 'openrouter'
- Results are streamed in real-time for immediate feedback
- Tool calls are automatically cached to prevent redundant operations
- Often the MCP server will not be able to run because environment variables are not set. If this happens ask the user to add the missing environment variables to the cursor tools env file at ~/.vibe-tools/.env

**Stagehand Browser Automation:**
`vibe-tools browser open <url> [options]` - Open a URL and capture page content, console logs, and network activity (e.g., `vibe-tools browser open "https://example.com" --html`)
`vibe-tools browser act "<instruction>" --url=<url | 'current'> [options]` - Execute actions on a webpage using natural language instructions (e.g., `vibe-tools browser act "Click Login" --url=https://example.com`)
`vibe-tools browser observe "<instruction>" --url=<url> [options]` - Observe interactive elements on a webpage and suggest possible actions (e.g., `vibe-tools browser observe "interactive elements" --url=https://example.com`)
`vibe-tools browser extract "<instruction>" --url=<url> [options]` - Extract data from a webpage based on natural language instructions (e.g., `vibe-tools browser extract "product names" --url=https://example.com/products`)

**Notes on Browser Commands:**
- All browser commands are stateless unless --connect-to is used to connect to a long-lived interactive session. In disconnected mode each command starts with a fresh browser instance and closes it when done.
- When using `--connect-to`, special URL values are supported:
  - `current`: Use the existing page without reloading
  - `reload-current`: Use the existing page and refresh it (useful in development)
  - If working interactively with a user you should always use --url=current unless you specifically want to navigate to a different page. Setting the url to anything else will cause a page refresh loosing current state.
- Multi step workflows involving state or combining multiple actions are supported in the `act` command using the pipe (|) separator (e.g., `vibe-tools browser act "Click Login | Type 'user@example.com' into email | Click Submit" --url=https://example.com`)
- Video recording is available for all browser commands using the `--video=<directory>` option. This will save a video of the entire browser interaction at 1280x720 resolution. The video file will be saved in the specified directory with a timestamp.
- DO NOT ask browser act to "wait" for anything, the wait command is currently disabled in Stagehand.

**Tool Recommendations:**
- `vibe-tools web` is best for general web information not specific to the repository. Generally call this without additional arguments.
- `vibe-tools repo` is ideal for repository-specific questions, planning, code review and debugging. E.g. `vibe-tools repo "Review recent changes to command error handling looking for mistakes, omissions and improvements"`. Generally call this without additional arguments.
- `vibe-tools plan` is ideal for planning tasks. E.g. `vibe-tools plan "Adding authentication with social login using Google and Github"`. Generally call this without additional arguments.
- `vibe-tools doc` generates documentation for local or remote repositories.
- `vibe-tools youtube` analyzes YouTube videos to generate summaries, transcripts, implementation plans, or custom analyses
- `vibe-tools browser` is useful for testing and debugging web apps and uses Stagehand
- `vibe-tools mcp` enables interaction with specialized tools through MCP servers (e.g., for Git operations, file system tasks, or custom tools)
- When implementing features based on documentation, specifications, or any external content, always use the `--with-doc=<url>` flag instead of built-in web search. For example: `vibe-tools plan "Implement login page according to specs" --with-doc=https://example.com/specs.pdf` or `vibe-tools repo "How should I implement this feature?" --with-doc=https://example.com/feature-spec.md`.

- When a user provides a specific URL for documentation or reference material, always use the `--with-doc=<url>` flag with that URL rather than attempting to search for or summarize the content independently. This ensures the exact document is used as context.

**Running Commands:**
1. Use `vibe-tools <command>` to execute commands (make sure vibe-tools is installed globally using npm install -g vibe-tools so that it is in your PATH)

**General Command Options (Supported by all commands):**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, openrouter, modelbox, or xai). If provider is not specified, the default provider for that task will be used.
--model=<model name>: Specify an alternative AI model to use. If model is not specified, the provider's default model for that task will be used.
--max-tokens=<number>: Control response length
--save-to=<file path>: Save command output to a file (in *addition* to displaying it)
--debug: Show detailed logs and error information

**Repository Command Options:**
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for repository analysis
--max-tokens=<number>: Maximum tokens for response
--from-github=<GitHub username>/<repository name>[@<branch>]: Analyze a remote GitHub repository without cloning it locally
--subdir=<path>: Analyze a specific subdirectory instead of the entire repository
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times.

**Documentation Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Generate documentation for a remote GitHub repository
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for documentation generation
--max-tokens=<number>: Maximum tokens for response
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times.

**YouTube Command Options:**
--type=<summary|transcript|plan|review|custom>: Type of analysis to perform (default: summary)

**GitHub Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Access PRs/issues from a specific GitHub repository

**Browser Command Options (for 'open', 'act', 'observe', 'extract'):**
--console: Capture browser console logs (enabled by default, use --no-console to disable)
--html: Capture page HTML content (disabled by default)
--network: Capture network activity (enabled by default, use --no-network to disable)
--screenshot=<file path>: Save a screenshot of the page
--timeout=<milliseconds>: Set navigation timeout (default: 120000ms for Stagehand operations, 30000ms for navigation)
--viewport=<width>x<height>: Set viewport size (e.g., 1280x720). When using --connect-to, viewport is only changed if this option is explicitly provided
--headless: Run browser in headless mode (default: true)
--no-headless: Show browser UI (non-headless mode) for debugging
--connect-to=<port>: Connect to existing Chrome instance. Special values: 'current' (use existing page), 'reload-current' (refresh existing page)
--wait=<time:duration or selector:css-selector>: Wait after page load (e.g., 'time:5s', 'selector:#element-id')
--video=<directory>: Save a video recording (1280x720 resolution, timestamped subdirectory). Not available when using --connect-to
--url=<url>: Required for `act`, `observe`, and `extract` commands. Url to navigate to before the main command or one of the special values 'current' (to stay on the current page without navigating or reloading) or 'reload-current' (to reload the current page)
--evaluate=<string>: JavaScript code to execute in the browser before the main command

**Nicknames**
Users can ask for these tools using nicknames
Gemini is a nickname for vibe-tools repo
Perplexity is a nickname for vibe-tools web
Stagehand is a nickname for vibe-tools browser
If people say "ask Gemini" or "ask Perplexity" or "ask Stagehand" they mean to use the `vibe-tools` command with the `repo`, `web`, or `browser` commands respectively.

**Xcode Commands:**
`vibe-tools xcode build [buildPath=<path>] [destination=<destination>]` - Build Xcode project and report errors.
**Build Command Options:**
--buildPath=<path>: (Optional) Specifies a custom directory for derived build data. Defaults to ./.build/DerivedData.
--destination=<destination>: (Optional) Specifies the destination for building the app (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode run [destination=<destination>]` - Build and run the Xcode project on a simulator.
**Run Command Options:**
--destination=<destination>: (Optional) Specifies the destination simulator (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode lint` - Run static analysis on the Xcode project to find and fix issues.

**Additional Notes:**
- For detailed information, see `node_modules/vibe-tools/README.md` (if installed locally).
- Configuration is in `vibe-tools.config.json` (or `~/.vibe-tools/config.json`).
- API keys are loaded from `.vibe-tools.env` (or `~/.vibe-tools/.env`).
- ClickUp commands require a `CLICKUP_API_TOKEN` to be set in your `.vibe-tools.env` file.
- Available models depend on your configured provider (OpenAI, Anthropic, xAI, etc.) in `vibe-tools.config.json`.
- repo has a limit of 2M tokens of context. The context can be reduced by filtering out files in a .repomixignore file.
- problems running browser commands may be because playwright is not installed. Recommend installing playwright globally.
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY`
- **Remember:** You're part of a team of superhuman expert AIs. Work together to solve complex problems.
- **Repomix Configuration:** You can customize which files are included/excluded during repository analysis by creating a `repomix.config.json` file in your project root. This file will be automatically detected by `repo`, `plan`, and `doc` commands.

<!-- vibe-tools-version: 0.60.9 -->
</vibe-tools Integration>
</file>

<file path="src/.repomix-output.txt">
This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
api.ts
App.tsx
asap_cpu.rs
changes-summary.md
index.css
main.rs
mp.rs
plot_ci.rs
plot_ratings.rs
sorter.rs
web_service.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="api.ts">
// src/api.ts
const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:3000";
export async function fetchHealth(): Promise<string> {
  const res = await fetch(`${API_BASE_URL}/healthz`);
  if (!res.ok) throw new Error('API health check failed');
  return res.text();
}
// Add more API functions as backend endpoints are defined
</file>

<file path="App.tsx">
import React, { useState } from 'react';
import MonacoEditor from '@monaco-editor/react';
import { fetchHealth } from './api';
function App() {
  const [markdown, setMarkdown] = useState<string>(
    '# Welcome to the Comparison Sorter App!\n\nEdit this markdown and see Monaco Editor in action.'
  );
  const [apiStatus, setApiStatus] = useState<string | null>(null);
  const [apiError, setApiError] = useState<string | null>(null);
  const checkApi = async () => {
    setApiStatus(null);
    setApiError(null);
    try {
      const status = await fetchHealth();
      setApiStatus(status);
    } catch (err: any) {
      setApiError(err.message || 'Unknown error');
    }
  };
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 p-4">
      <h1 className="text-4xl font-bold text-blue-600 mb-4">Comparison Sorter App</h1>
      <p className="text-lg text-gray-700 mb-6">React + Vite + Tailwind CSS + Monaco Editor</p>
      <div className="w-full max-w-2xl h-96 shadow-lg border border-gray-200 rounded mb-6">
        <MonacoEditor
          height="100%"
          defaultLanguage="markdown"
          value={markdown}
          onChange={value => setMarkdown(value || '')}
          options={{
            minimap: { enabled: false },
            wordWrap: 'on',
            fontSize: 16,
          }}
        />
      </div>
      <button
        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition mb-2"
        onClick={checkApi}
      >
        Test Railway Backend API
      </button>
      {apiStatus && <div className="text-green-600">API Response: {apiStatus}</div>}
      {apiError && <div className="text-red-600">API Error: {apiError}</div>}
    </div>
  );
}
export default App;
</file>

<file path="asap_cpu.rs">
use libm::{erf, erfc, exp};
use std::f64::consts::PI;
// perf ideas:
// - use selective EIG a la (https://arxiv.org/abs/2004.05691) (~only eval posterior on pairs with closeish ratings)
// - dynamically set threshold based on gradient of KL divergence and maybe best known EIG?
//   - compute gradients of element posteriors by other element posteriors & use that to propagate gradients?
//   - doable with autodiff i think, just backprop on KL div & use gradients of posteriors as thresholds
// - prio queue for updates in message passing by magnitude of update?
pub struct ASAP {
    ts_solver: TrueSkillSolver,
}
impl ASAP {
    pub fn new(n: usize) -> Self {
        ASAP {
            ts_solver: TrueSkillSolver::new(n),
        }
    }
    pub fn run_asap(
        &mut self,
        m: &[Vec<i32>],
    ) -> ((usize, usize), Vec<Vec<f64>>, Vec<f64>, Vec<f64>) {
        let n = m.len();
        let g = self.unroll_mat(m);
        self.compute_information_gain_mat(n, &g)
    }
    fn unroll_mat(&self, m: &[Vec<i32>]) -> Vec<[usize; 2]> {
        let n = m.len();
        let mut g = Vec::new();
        for i in 0..n {
            for j in 0..n {
                if m[i][j] > 0 {
                    // TODO use counts in trueskill solver instead of this loop
                    for _ in 0..m[i][j] {
                        g.push([i, j]);
                    }
                }
            }
        }
        g
    }
    fn compute_prob_cmps(&self) -> Vec<Vec<f64>> {
        let (means, vrs) = (self.ts_solver.ms.as_slice(), self.ts_solver.vs.as_slice());
        let n = means.len();
        let mut prob = vec![vec![0.0; n]; n];
        for i in 0..n {
            for j in 0..n {
                if i == j {
                    prob[i][j] = 0.0;
                } else {
                    let diff_means = means[i] - means[j];
                    let vars_sum = 1.0 + vrs[i] + vrs[j];
                    prob[i][j] = ndtr(diff_means / vars_sum.sqrt());
                }
            }
        }
        prob
    }
    fn compute_information_gain_mat(
        &mut self,
        n: usize,
        g: &[[usize; 2]],
    ) -> ((usize, usize), Vec<Vec<f64>>, Vec<f64>, Vec<f64>) {
        let mut kl_divs = vec![vec![0.0; n]; n];
        self.ts_solver.push_many(g);
        let (ms_curr, vs_curr) = self.ts_solver.solve(true);
        let prob = self.compute_prob_cmps();
        for i in 1..n {
            for j in 0..i {
                let kl1 = {
                    let (ms, vs) = self.ts_solver.solve_one((i, j));
                    kl_divergence(&ms, &vs, &ms_curr, &vs_curr)
                };
                let kl2 = {
                    let (ms, vs) = self.ts_solver.solve_one((j, i));
                    kl_divergence(&ms, &vs, &ms_curr, &vs_curr)
                };
                kl_divs[i][j] = prob[i][j] * kl1 + prob[j][i] * kl2;
            }
        }
        let pair_to_compare = self.get_maximum(&kl_divs);
        (pair_to_compare, prob, ms_curr, vs_curr)
    }
    fn get_maximum(&self, gain_mat: &[Vec<f64>]) -> (usize, usize) {
        // use rand::distributions::{Distribution, WeightedIndex};
        // use rand::thread_rng;
        // let mut rng = thread_rng();
        let mut indices = Vec::new();
        let mut weights = Vec::new();
        println!("gain_mat: {:?}", gain_mat);
        for (i, row) in gain_mat.iter().enumerate() {
            for (j, &gain) in row.iter().enumerate() {
                indices.push((i, j));
                weights.push(exp(gain * 20.0));
            }
        }
        // let dist = WeightedIndex::new(&weights).unwrap();
        // let chosen_index = dist.sample(&mut rng);
        let chosen_index = weights
            .iter()
            .zip(&indices)
            .enumerate()
            .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())
            .unwrap()
            .0;
        let chosen_pair = indices[chosen_index];
        let max_gain = gain_mat
            .iter()
            .flat_map(|row| row.iter().cloned())
            .fold(0.0, f64::max);
        println!(
            "Chosen EIG: {}, Max EIG: {}",
            gain_mat[chosen_pair.0][chosen_pair.1], max_gain
        );
        chosen_pair
    }
}
struct FastUsizeSet {
    set: Vec<bool>,
    vec: Vec<usize>,
}
impl FastUsizeSet {
    fn new(n: usize) -> Self {
        FastUsizeSet {
            set: vec![false; n],
            vec: Vec::new(),
        }
    }
    fn add(&mut self, i: usize) {
        if self.set[i] {
            return;
        }
        self.set[i] = true;
        self.vec.push(i);
    }
    fn pop(&mut self) -> Option<usize> {
        let i = self.vec.pop();
        if let Some(i) = i {
            self.set[i] = false;
        }
        i
    }
}
struct TrueSkillSolver {
    n: usize,
    ms: Vec<f64>,
    vs: Vec<f64>,
    mgs: Vec<[f64; 2]>,
    pgs: Vec<[f64; 2]>,
    var_to_cmps0: Vec<Vec<usize>>,
    var_to_cmps1: Vec<Vec<usize>>,
    g: Vec<[usize; 2]>,
}
impl TrueSkillSolver {
    pub fn new(n: usize) -> Self {
        TrueSkillSolver {
            n,
            ms: vec![0.0; n],
            vs: vec![0.5; n],
            mgs: Vec::new(),
            pgs: Vec::new(),
            var_to_cmps0: vec![vec![]; n],
            var_to_cmps1: vec![vec![]; n],
            g: Vec::new(),
        }
    }
    fn push_many(&mut self, g: &[[usize; 2]]) {
        for &[a, b] in g {
            self.push_cmp(a, b);
        }
    }
    fn push_cmp(&mut self, i: usize, j: usize) {
        self.pgs.push([0.0; 2]);
        self.mgs.push([0.0; 2]);
        self.g.push([i, j]);
        let id = self.pgs.len() - 1;
        self.var_to_cmps0[i].push(id);
        self.var_to_cmps1[j].push(id);
    }
    fn pop_cmp(&mut self, i: usize, j: usize) {
        self.pgs.pop();
        self.mgs.pop();
        self.g.pop();
        let id = self.pgs.len();
        self.var_to_cmps0[i].retain(|&x| x != id);
        self.var_to_cmps1[j].retain(|&x| x != id);
    }
    // pub fn solve_with_cmp(
    //     &mut self,
    //     g: &[[usize; 2]],
    //     num_iters: usize,
    //     cmp: (usize, usize),
    // ) -> (Vec<f64>, Vec<f64>) {
    // }
    //
    pub fn solve(&mut self, save: bool) -> (Vec<f64>, Vec<f64>) {
        let mut todo_vars = FastUsizeSet::new(self.n);
        let mut todo_cmps = FastUsizeSet::new(self.g.len());
        for p in 0..self.n {
            todo_vars.add(p);
        }
        for j in 0..self.g.len() {
            todo_cmps.add(j);
        }
        self._solve(todo_vars, todo_cmps, save, 0.001)
    }
    pub fn solve_one(&mut self, cmp: (usize, usize)) -> (Vec<f64>, Vec<f64>) {
        self.push_cmp(cmp.0, cmp.1);
        let mut todo_vars = FastUsizeSet::new(self.n);
        let mut todo_cmps = FastUsizeSet::new(self.g.len());
        todo_vars.add(cmp.0);
        todo_vars.add(cmp.1);
        todo_cmps.add(self.g.len() - 1);
        // TODO could run top k candidates again with a lower threshold
        let r = self._solve(todo_vars, todo_cmps, false, 0.1);
        self.pop_cmp(cmp.0, cmp.1);
        r
    }
    pub fn _solve(
        &mut self,
        mut todo_vars: FastUsizeSet,
        mut todo_cmps: FastUsizeSet,
        save: bool,
        threshold: f64,
    ) -> (Vec<f64>, Vec<f64>) {
        let mut pgs = self.pgs.clone();
        let mut mgs = self.mgs.clone();
        let mut ps: Vec<f64> = self.vs.iter().map(|&v| 1.0 / v).collect();
        let mut ms = self.ms.clone();
        let mut sum_pgs_mgs = vec![0.0; self.n];
        let mut sum_pgs = vec![0.0; self.n];
        // assert!(n_cmps == pgs.len());
        // assert!(n_cmps == mgs.len());
        // assert!(n_cmps == self.g.len());
        assert!(self.n == sum_pgs.len());
        assert!(self.n == sum_pgs_mgs.len());
        assert!(self.n == ps.len());
        assert!(self.n == ms.len());
        let g = &self.g;
        for _i in 0..1000 {
            // println!("iter {}, todo_cmps {}", _i, todo_cmps.vec.len());
            if todo_cmps.vec.len() == 0 {
                break;
            }
            while let Some(j) = todo_cmps.pop() {
                // TODO to avoid bounds check but can't use nightly bc raj :(
                // unsafe {
                //     std::intrinsics::assume(g[j][0] < self.n && g[j][1] < self.n);
                //     std::intrinsics::assume(j < self.g.len());
                // }
                // unsafe {
                //     std::intrinsics::assume(g[j][0] < self.n && g[j][1] < self.n);
                // }
                let psg0 = ps[g[j][0]] - pgs[j][0];
                let psg1 = ps[g[j][1]] - pgs[j][1];
                let msg0 = (ps[g[j][0]] * ms[g[j][0]] - pgs[j][0] * mgs[j][0]) / psg0;
                let msg1 = (ps[g[j][1]] * ms[g[j][1]] - pgs[j][1] * mgs[j][1]) / psg1;
                let vgt = 1.0 + 1.0 / psg0 + 1.0 / psg1;
                let mgt = msg0 - msg1;
                let (ps_val, lmb) = psi_lamb(mgt / vgt.sqrt());
                let mt = mgt + vgt.sqrt() * ps_val;
                let pt = 1.0 / (vgt * (1.0 - lmb));
                let ptg = pt - 1.0 / vgt;
                let mtg = (mt * pt - mgt / vgt) / (ptg + f64::EPSILON);
                pgs[j][0] = 1.0 / (1.0 + 1.0 / ptg + 1.0 / psg1);
                pgs[j][1] = 1.0 / (1.0 + 1.0 / ptg + 1.0 / psg0);
                mgs[j][0] = msg1 + mtg;
                mgs[j][1] = msg0 - mtg;
                todo_vars.add(g[j][0]);
                todo_vars.add(g[j][1]);
            }
            while let Some(p) = todo_vars.pop() {
                sum_pgs[p] = 0.0;
                sum_pgs_mgs[p] = 0.0;
                for &i in &self.var_to_cmps0[p] {
                    sum_pgs[p] += pgs[i][0];
                    sum_pgs_mgs[p] += pgs[i][0] * mgs[i][0];
                }
                for &i in &self.var_to_cmps1[p] {
                    sum_pgs[p] += pgs[i][1];
                    sum_pgs_mgs[p] += pgs[i][1] * mgs[i][1];
                }
                let ps_ = 0.02 + sum_pgs[p];
                let ms_ = sum_pgs_mgs[p] / ps_;
                if (ms_ - ms[p]).abs() > threshold || (ps_ - ps[p]).abs() > threshold {
                    // println!("p {} ms {} -> {} ps {} -> {}", p, ms[p], ms_, ps[p], ps_);
                    for &i in &self.var_to_cmps0[p] {
                        todo_cmps.add(i);
                    }
                    for &i in &self.var_to_cmps1[p] {
                        todo_cmps.add(i);
                    }
                }
                ps[p] = ps_;
                ms[p] = ms_;
            }
        }
        if ps.iter().any(|&p| p.is_nan()) || ms.iter().any(|&m| m.is_nan()) {
            panic!("NaN in ps/ms: ps: {:?}\nms: {:?}", ps, ms);
        }
        if save {
            self.vs = ps.iter().map(|&p| 1.0 / p).collect();
            self.ms = ms.clone();
            self.pgs = pgs;
            self.mgs = mgs;
        }
        (ms, ps.iter().map(|&p| 1.0 / p).collect())
    }
}
// Helper functions
fn kl_divergence(mean_1: &[f64], var_1: &[f64], mean_2: &[f64], var_2: &[f64]) -> f64 {
    0.5 * (var_2.iter().map(|&x| x.ln()).sum::<f64>() - var_1.iter().map(|&x| x.ln()).sum::<f64>()
        + var_1
            .iter()
            .zip(var_2.iter())
            .map(|(&v1, &v2)| v1 / v2)
            .sum::<f64>()
        + mean_1
            .iter()
            .zip(mean_2.iter())
            .zip(var_2.iter())
            .map(|((&m1, &m2), &v2)| (m2 - m1).powi(2) / v2)
            .sum::<f64>()
        - mean_1.len() as f64)
}
// too slow :(
// TODO could use simd w/ sleef for erf
fn kl_div_pairs(mean_1: &[f64], var_1: &[f64], mean_2: &[f64], var_2: &[f64]) -> f64 {
    let mut sorted_ixs = (0..mean_1.len()).collect::<Vec<_>>();
    sorted_ixs.sort_by(|&i, &j| mean_1[i].partial_cmp(&mean_1[j]).unwrap());
    let mut kl = 0.0;
    for i in 0..mean_1.len() {
        let m1l = mean_1[i];
        let v1l = var_1[i];
        let m2l = mean_2[i];
        let v2l = var_2[i];
        if (m1l - m2l).abs() < 1e-6 && (v1l - v2l).abs() < 1e-6 {
            continue;
        }
        // only compare closest 4 items to each i
        // FIXME need to sort by mean first
        for j in (i.saturating_sub(2))..(i + 3).min(mean_1.len()) {
            let m1r = mean_1[j];
            let v1r = var_1[j];
            let m2r = mean_2[j];
            let v2r = var_2[j];
            let v1_sum = 1.0 + v1l + v1r;
            let v2_sum = 1.0 + v2l + v2r;
            // TODO get q from prob cmps
            let p = ndtr((m1l - m1r) / v1_sum.sqrt());
            let q = ndtr((m2l - m2r) / v2_sum.sqrt());
            kl += p * (p / q).ln();
            // kl += (1.0 - p) * ((1.0 - p) / (1.0 - q)).ln();
        }
    }
    kl
}
fn ndtr(a: f64) -> f64 {
    if a.is_nan() {
        return f64::NAN;
    }
    let x = a * (1.0 / 2.0_f64.sqrt());
    let z = x.abs();
    if z < (1.0 / 2.0_f64.sqrt()) {
        0.5 + 0.5 * erf(x)
    } else {
        let y = 0.5 * erfc(z);
        if x > 0.0 {
            1.0 - y
        } else {
            y
        }
    }
}
fn psi_lamb(x: f64) -> (f64, f64) {
    let p = exp(-x * x / 2.0) / (2.0 * PI).sqrt();
    let c = ndtr(x);
    let ps = p / c;
    (ps, ps * (ps + x))
}
</file>

<file path="changes-summary.md">
# Changes Made to Use Markdown as Source of Truth

## Backend Changes

1. Removed TaskInfo storage in AppState
2. Added ContentComparison for task content-based comparisons
3. Updated API to use content-based task identification
4. Removed task registration/storage endpoints
5. Rankings now derived from comparison content

## Frontend Changes

1. Removed registeredTasks state
2. Removed all task synchronization code
3. API client now sends task content directly
4. Task ID generation now just for UI purposes
5. Simplified App.tsx to use markdown as source of truth

## Benefits

1. No more 'ghost' tasks in rankings
2. Tasks only exist in markdown
3. UI shows only what's in the markdown
4. Simple mental model - what you see is what you get
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="main.rs">
// #![feature(let_chains)]
// #![feature(core_intrinsics)]
mod asap_cpu;
mod mp;
mod plot_ci;
pub mod plot_ratings;
mod sorter;
mod web_service;
#[tokio::main]
async fn main() {
    // Check for command line arguments
    let args: Vec<String> = std::env::args().collect();
    // If "api" argument is provided, run the web service
    if args.len() > 1 && args[1] == "api" {
        println!("Starting API server...");
        web_service::run_web_service().await;
    } else {
        // Otherwise, run the original sorter CLI
        if let Err(e) = sorter::main() {
            eprintln!("Error: {}", e);
        }
    }
}
</file>

<file path="mp.rs">
// struct Normal<M, P, O> {}
//
//
</file>

<file path="plot_ci.rs">
use std::fs::File;
use std::io::Write;
fn escape_xml(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}
pub fn plot_ci(mut items: Vec<(String, f64, f64)>, filename: &str) -> std::io::Result<()> {
    // Sort items by mean in descending order
    items.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    let graph_width = 400.0;
    let left_margin = 50.0; // Reduced left margin
    let right_margin = 1200.0; // Increased right margin for labels
    let total_width = left_margin + graph_width + right_margin;
    let row_height = 20.0;
    let height = row_height * items.len() as f64 + 40.0; // Add some extra space at the bottom
    let min_mean = items
        .iter()
        .map(|&(_, m, _)| m)
        .fold(f64::INFINITY, f64::min);
    let max_mean = items
        .iter()
        .map(|&(_, m, _)| m)
        .fold(f64::NEG_INFINITY, f64::max);
    let range = max_mean - min_mean;
    let mut svg = format!(
        r#"<svg xmlns="http://www.w3.org/2000/svg" width="{}" height="{}">"#,
        total_width, height
    );
    // Add a white background
    svg.push_str(&format!(
        r#"<rect width="100%" height="100%" fill="white"/>"#
    ));
    // Add vertical line separating labels from graph
    svg.push_str(&format!(
        r#"<line x1="{}" y1="0" x2="{}" y2="{}" stroke="\#ccc" stroke-width="1"/>"#,
        left_margin, left_margin, height
    ));
    for (i, (name, mean, var)) in items.iter().enumerate() {
        let y = i as f64 * row_height + 20.0; // Add some top padding
        let x = left_margin + (graph_width * (max_mean - mean) / range);
        let ci_width = graph_width * (var.sqrt() * 1.645) / range; // 90% confidence interval
        // Add confidence interval line
        svg.push_str(&format!(
            r#"<line x1="{}" y1="{}" x2="{}" y2="{}" stroke="black" stroke-width="2"/>"#,
            x - ci_width / 2.0,
            y,
            x + ci_width / 2.0,
            y
        ));
        // Add mean point
        svg.push_str(&format!(
            r#"<circle cx="{}" cy="{}" r="4" fill="blue"/>"#,
            x, y
        ));
        // Add label to the left of the CI
        let label_x = x + ci_width / 2.0 + 10.0;
        svg.push_str(&format!(
            r#"<text x="{}" y="{}" font-family="Arial, sans-serif" font-size="14" text-anchor="start" dominant-baseline="middle">{}</text>"#,
            label_x,
            y,
            escape_xml(&truncate_text(name, 200))
        ));
    }
    svg.push_str("</svg>");
    File::create(filename)?.write_all(svg.as_bytes())?;
    Ok(())
}
fn truncate_text(s: &str, max_chars: usize) -> String {
    if s.chars().count() <= max_chars {
        s.to_string()
    } else {
        let mut truncated: String = s.chars().take(max_chars - 3).collect();
        truncated.push_str("...");
        truncated
    }
}
</file>

<file path="plot_ratings.rs">
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::process::Command;
// fn rating_to_color(range: f64, rating: f64) -> String {
//     // let clamped_rating = rating.max(-2.0).min(2.0);
//     color_from_norm(normalized)
// }
fn color_from_norm(norm: f64) -> String {
    if norm < 0.5 {
        let r = 255;
        let g = (255.0 * (norm * 2.0)) as u8;
        format!("#{:02X}{:02X}00", r, g)
    } else {
        let r = (255.0 * ((1.0 - norm) * 2.0)) as u8;
        let g = 255;
        format!("#{:02X}{:02X}00", r, g)
    }
}
fn edge_color_from_norm(norm: f64) -> String {
    let intensity = (255.0 * (1.0 - norm)) as u8;
    format!("#{:02X}{:02X}{:02X}", intensity, intensity, intensity)
}
fn dfs(
    edges: &HashMap<usize, Vec<usize>>,
    from: usize,
    visited: &mut HashSet<usize>,
    map: &HashMap<(usize, usize), f64>,
    ok: &impl Fn(&f64) -> bool,
) {
    if !visited.insert(from) {
        return;
    }
    for to in edges.get(&from).unwrap_or(&vec![]) {
        if ok(map.get(&(from, *to)).unwrap()) {
            dfs(edges, *to, visited, map, ok);
        }
    }
}
fn transitive_reduction(edges: &mut HashMap<(usize, usize), f64>, ok: &impl Fn(&f64) -> bool) {
    // let mut edges_to_remove = Vec::new();
    let mut map: HashMap<usize, Vec<usize>> = HashMap::new();
    let mut nodes: Vec<usize> = edges.keys().map(|(x, _)| *x).collect();
    nodes.sort();
    for (from, to) in edges.keys() {
        map.entry(*from).or_insert_with(Vec::new).push(*to);
    }
    let mut edges_to_remove = HashSet::new();
    let mut dfs_buf: HashSet<usize> = HashSet::new();
    for n1 in nodes.iter() {
        for n2 in map.get(n1).unwrap_or(&vec![]) {
            if edges_to_remove.contains(n2) {
                continue;
            }
            dfs_buf.insert(*n1);
            dfs(&map, *n2, &mut dfs_buf, &edges, ok);
            for n3 in dfs_buf.iter() {
                if n2 == n3 || n1 == n3 {
                    continue;
                }
                edges_to_remove.insert(*n3);
            }
            dfs_buf.clear();
            // }
        }
        for y in edges_to_remove.iter() {
            edges.remove(&(*n1, *y));
            map.get_mut(n1)
                .unwrap()
                .retain(|z| !edges_to_remove.contains(z));
        }
        edges_to_remove.clear();
    }
}
pub fn plot_ratings(
    input_file: &str,
    output_file: &str,
    ms_curr: &[f64],
    id_to_index: &HashMap<usize, usize>,
    prob: &[Vec<f64>],
) -> io::Result<()> {
    let print = false;
    // let mut dot_content = String::from("digraph {\n  rankdir=LR;\nnewrank=true;\n");
    let mut dot_content =
        // String::from("digraph {\n  rankdir=LR;\nTBbalance=\"max\"\nratio=\"compress\"\n");
        // String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nranksep=\"0.1\"\nsplines=line\n");
        // String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nmargin=0\nnodesep=\"0.02\"\nranksep=\"0.05\"\nconcentrate=true\n");
        String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nmargin=0\nnodesep=\"0.02\"\nranksep=\"0.05\"\n");
    // String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nmargin=0\nnodesep=\"0.02\"\nranksep=\"0.05\"\n");
    // \nranksep=\"0.1\"\n");
    let rating_min = ms_curr.iter().fold(f64::INFINITY, |acc, &p| acc.min(p));
    let rating_max = ms_curr.iter().fold(f64::NEG_INFINITY, |acc, &p| acc.max(p));
    let rating_range = rating_max - rating_min;
    if print {
        println!("{:?}", (rating_min, rating_max, rating_range));
    }
    for (id, idx) in id_to_index.iter() {
        let rating = ms_curr[*idx];
        let color = color_from_norm((rating - rating_min) / rating_range);
        dot_content.push_str(&format!(
            // "  {} [label=\"{}\", style=filled, fillcolor=\"{}\"];\n",
            "  {} [label=\"{}\", style=filled, fillcolor=\"{}\"];\n",
            id, id, color
        ));
    }
    let Ok(file) = File::open(input_file) else {
        return Ok(());
    };
    let reader = io::BufReader::new(file);
    let mut edges: HashMap<(usize, usize), f64> = HashMap::new();
    for line in reader.lines() {
        let line = line?;
        let parts: Vec<&str> = line.split(',').collect();
        if parts.len() == 2 {
            let from = parts[0].parse::<usize>().unwrap();
            let to = parts[1].parse::<usize>().unwrap();
            if id_to_index.contains_key(&from) && id_to_index.contains_key(&to) {
                let p = prob[id_to_index[&from]][id_to_index[&to]];
                edges.insert((from, to), p);
            }
        }
    }
    transitive_reduction(&mut edges, &|p| *p > 0.5);
    transitive_reduction(&mut edges, &|p| *p < 0.5);
    // transitive_reduction(&mut edges, &|p| *p > 0.4);
    // transitive_reduction(&mut edges, &|p| *p < 0.6);
    // transitive_reduction(&mut edges, &|_| true);
    if print {
        println!("Edges after transitive reduction: {:?}", edges.len());
    }
    for ((from, to), &p) in edges.iter() {
        // let d = if ms_map[&from] < ms_map[&to] {
        //     ((ms_map[&from] - ms_map[&to]) / 0.3).floor()
        // } else {
        //     ((ms_map[&from] - ms_map[&to]) / 0.2).floor().max(1.0)
        // };
        // TODO maybe also use variance here?
        // maybe use cmp prob?
        // println!("{:?}", p);
        // let d = ((p - 0.5) * 2.0).powf(3.0);
        // let d = ms_map[&to] - ms_map[&from];
        // let d =
        dot_content.push_str(&format!(
            "  {} -> {} [color=\"{}\"{}];\n",
            &from,
            &to,
            edge_color_from_norm(p),
            if p > 0.5 {
                // ",weight=10"
                ""
            } else if p > 0.45 {
                ",minlen=0"
            } else if p > 0.35 {
                ",minlen=0,weight=0"
                // ",minlen=0,weight=1"
            } else {
                ",minlen=0,constraint=false"
            }
        ));
        // dot_content.push_str(&format!("  {} -> {} [len={}];\n", &from, &to, d));
        // let w = p * 0.3;
        // if ms_map[&from] < ms_map[&to] {
        //     let d = ((ms_map[&from] - ms_map[&to]) * w).ceil();
        //     dot_content.push_str(&format!("  {} -> {} [minlen={}];\n", &from, &to, d));
        //     // dot_content.push_str(&format!("  {} -> {} [minlen=0];\n", &from, &to));
        // } else {
        //     let d = ((ms_map[&from] - ms_map[&to]) * (w / 1.0)).ceil();
        //     dot_content.push_str(&format!("  {} -> {} [minlen={}];\n", &from, &to, d));
        // }
    }
    dot_content.push_str("}\n");
    let output_dot = format!("{}.dot", output_file);
    let output_png = format!("{}.png", output_file);
    // Save the dot file
    std::fs::write(&output_dot, &dot_content)?;
    if print {
        println!("Dot file saved as {}", output_dot);
    }
    // Generate PNG from dot file
    // let command = format!("tred {} | dot -Tpng -o {}", output_dot, output_png);
    let command = format!("dot -Tpng {} -o {}", output_dot, output_png);
    // let command = format!("tred {} | fdp -Tpng -o {}", output_dot, output_png);
    let out = Command::new("sh").arg("-c").arg(&command).output()?;
    if print {
        io::stdout().write_all(&out.stdout)?;
        io::stderr().write_all(&out.stderr)?;
        println!("Graph saved as {}", output_png);
    }
    Ok(())
}
</file>

<file path="sorter.rs">
use rand::Rng;
use tuple_map::TupleMap2;
use crate::asap_cpu::ASAP;
use crate::plot_ci::plot_ci;
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::process::Command;
use std::thread;
const EMOJIS: &[&str] = &["📅", "⏳", "✅"];
pub fn main() -> io::Result<()> {
    let mut args = std::env::args();
    args.next();
    let dir = args.next().unwrap();
    std::env::set_current_dir(dir.clone())?;
    println!(
        "dir: {} (should be = {})",
        std::env::current_dir()?.display(),
        dir
    );
    loop {
        run()?
    }
}
fn run() -> io::Result<()> {
    let (mut with_rid, mut without_rid) = get_todos()?;
    if without_rid.is_empty() && with_rid.is_empty() {
        println!("No todos found");
        return Ok(());
    }
    let comparisons = if let Ok(file) = File::open("ratings.log") {
        let fr = io::BufReader::new(&file);
        fr.lines()
            .filter_map(|line| {
                let line = line.ok()?;
                if let [i, j] = line
                    .split(',')
                    .filter_map(|s| s.parse().ok())
                    .filter(|&i| with_rid.contains_key(&i))
                    .collect::<Vec<_>>()[..]
                {
                    Some((i, j))
                } else {
                    None
                }
            })
            .collect()
    } else {
        Vec::new()
    };
    let mut id_to_index: HashMap<_, _> = with_rid
        .iter()
        .enumerate()
        .map(|(i, (&id, _))| (id, i))
        .collect();
    let mut index_to_id: HashMap<_, _> = id_to_index.iter().map(|(&k, &v)| (v, k)).collect();
    let n = with_rid.len() + if without_rid.is_empty() { 0 } else { 1 };
    let mut m = vec![vec![0; n]; n];
    for &(i, j) in &comparisons {
        if id_to_index.contains_key(&i) && id_to_index.contains_key(&j) {
            m[id_to_index[&i]][id_to_index[&j]] += 1;
        }
    }
    // println!("m: {:?}", m);
    // println!("n: {}", n);
    let mut asap = ASAP::new(n);
    let (pair, prob, ms_curr, vs_curr) = asap.run_asap(&m);
    {
        let id_to_index = id_to_index.clone();
        let prob = prob.clone();
        let ms_curr = ms_curr.clone();
        thread::spawn(move || {
            crate::plot_ratings::plot_ratings(
                "ratings.log",
                "ratings_graph",
                &ms_curr,
                &id_to_index,
                &prob,
            )
            .unwrap();
        });
    }
    {
        let index_to_id = index_to_id.clone();
        let ms_curr = ms_curr.clone();
        let vs_curr = vs_curr.clone();
        let with_rid = with_rid.clone();
        thread::spawn(move || {
            let items: Vec<_> = ms_curr
                .iter()
                .zip(vs_curr.iter())
                .enumerate()
                .filter_map(|(i, (&m, &v))| {
                    index_to_id
                        .get(&i)
                        .and_then(|&id| with_rid.get(&id).map(|t| (t.todo.clone(), m, v)))
                })
                .collect();
            plot_ci(items, "ratings_ci.html").unwrap();
        });
    }
    // assign an id / add [[rid::]] to a random todo in without_rid
    if !without_rid.is_empty() && (pair.0 == n - 1 || pair.1 == n - 1) {
        let ix = n - 1;
        let rid = with_rid.iter().map(|(id, _)| id).max().unwrap_or(&0usize) + 1;
        let mut rng = rand::thread_rng();
        let idx = rng.gen_range(0..without_rid.len());
        let todo = without_rid.swap_remove(idx);
        let new_line = if let Some(pos) = EMOJIS.iter().filter_map(|e| todo.todo.find(e)).min() {
            format!(
                "{} [[rid::{}]] {}",
                &todo.todo[..pos],
                rid,
                &todo.todo[pos..]
            )
        } else {
            format!("{} [[rid::{}]]", todo.todo, rid)
        };
        with_rid.insert(rid, todo.clone());
        index_to_id.insert(ix, rid);
        id_to_index.insert(rid, ix);
        replace_line_in_file(&todo.file, todo.line_num, &new_line)?;
    }
    let pair = pair.map(|i| index_to_id.get(&i).unwrap());
    pair.for_each(|id| {
        let t = with_rid.get(id).unwrap();
        println!("{} ({}:{})", t.todo, t.file, t.line_num);
    });
    print!("Enter 1 or 2: ");
    io::stdout().flush()?;
    let c = console::Term::stdout().read_char()?;
    println!();
    let mut file = if let Ok(file) = File::options().append(true).open("ratings.log") {
        file
    } else {
        File::create("ratings.log")?
    };
    writeln!(
        file,
        "{},{}",
        if c == '1' { pair.0 } else { pair.1 },
        if c == '1' { pair.1 } else { pair.0 }
    )?;
    Ok(())
}
#[derive(Clone)]
struct Todo {
    file: String,
    line_num: usize,
    todo: String,
}
fn get_todos() -> io::Result<(HashMap<usize, Todo>, Vec<Todo>)> {
    let command_output = Command::new("rg")
        .args(&[r"^\s*- \[ \]", ".", "-n"])
        .output()?;
    let output = String::from_utf8_lossy(&command_output.stdout);
    if !command_output.status.success() {
        println!("Error running rg, is it installed?");
    }
    let mut with_rid = HashMap::new();
    let mut without_rid = Vec::new();
    for line in output.lines() {
        let parts: Vec<&str> = line.splitn(3, ':').collect();
        if parts.len() == 3 {
            let line = parts[2];
            let todo = Todo {
                file: parts[0].to_string(),
                line_num: parts[1].parse().unwrap(),
                todo: line.to_string(),
            };
            if let Some(start) = line.find("[[rid::") {
                if let Some(end) = line[start..].find("]]") {
                    if let Ok(rid) = line[start + 7..start + end].parse() {
                        with_rid.insert(rid, todo);
                    } else {
                        println!("Invalid rid: {}", &line[start + 7..start + end]);
                    }
                } else {
                    println!("Invalid rid: {}", &line[start..]);
                }
            } else {
                without_rid.push(todo);
            }
        }
    }
    Ok((with_rid, without_rid))
}
fn replace_line_in_file(file: &str, line_num: usize, new_content: &str) -> io::Result<()> {
    let content = std::fs::read_to_string(file)?;
    let mut lines: Vec<String> = content.lines().map(String::from).collect();
    if line_num > lines.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!("line {} is out of bounds", line_num),
        ));
    }
    lines[line_num - 1] = new_content.to_string();
    std::fs::write(file, lines.join("\n"))?;
    Ok(())
}
</file>

<file path="web_service.rs">
use axum::{
    extract::State,
    http::StatusCode,
    response::IntoResponse,
    routing::{get},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use tower_http::cors::{Any, CorsLayer};
use tokio::net::TcpListener;
use crate::asap_cpu::ASAP;
// Type for storing our application state
pub struct AppState {
    // Store comparisons with task content (not IDs)
    comparisons: Mutex<Vec<ContentComparison>>,
}
// Task info using content as the primary identifier
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct TaskInfo {
    content: String,
    completed: bool,
}
// Comparison with content-based task identification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContentComparison {
    task_a_content: String,
    task_b_content: String,
    winner_content: String,
    timestamp: String,
}
// For backward compatibility in responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LegacyComparison {
    task_a_id: usize,
    task_b_id: usize,
    winner_id: usize,
    timestamp: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct RankedTask {
    content: String,
    score: f64,
    rank: usize,
}
// Requests and responses
#[derive(Debug, Deserialize)]
pub struct AddComparisonRequest {
    task_a_content: String,
    task_b_content: String,
    winner_content: String,
}
#[derive(Debug, Serialize)]
pub struct ComparisonsResponse {
    comparisons: Vec<LegacyComparison>,
}
#[derive(Debug, Serialize)]
pub struct RankingsResponse {
    rankings: Vec<RankedTask>,
}
pub async fn run_web_service() {
    // Initialize tracing for better logging
    tracing_subscriber::fmt::init();
    // Create the application state
    let app_state = Arc::new(AppState {
        comparisons: Mutex::new(Vec::new()),
    });
    // Define CORS policy to allow requests from frontend
    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);
    // Create our API router
    let app = Router::new()
        .route("/health", get(health_check))
        .route("/comparisons", get(get_comparisons).post(add_comparison))
        .route("/rankings", get(get_rankings))
        .with_state(app_state)
        .layer(cors);
    // Run our service
    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let port = port.parse::<u16>().expect("PORT must be a number");
    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], port));
    tracing::info!("Listening on {}", addr);
    let listener = TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
// Health check endpoint
async fn health_check() -> impl IntoResponse {
    StatusCode::OK
}
// Get all comparisons
async fn get_comparisons(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    let comparisons = state.comparisons.lock().unwrap();
    // Convert content comparisons to legacy format for backward compatibility
    let mut content_to_id = HashMap::new();
    let mut next_id = 1;
    let legacy_comparisons: Vec<LegacyComparison> = comparisons
        .iter()
        .map(|comp| {
            // Assign IDs to task content
            let task_a_id = *content_to_id
                .entry(comp.task_a_content.clone())
                .or_insert_with(|| {
                    let id = next_id;
                    next_id += 1;
                    id
                });
            let task_b_id = *content_to_id
                .entry(comp.task_b_content.clone())
                .or_insert_with(|| {
                    let id = next_id;
                    next_id += 1;
                    id
                });
            let winner_id = if comp.winner_content == comp.task_a_content {
                task_a_id
            } else {
                task_b_id
            };
            LegacyComparison {
                task_a_id,
                task_b_id,
                winner_id,
                timestamp: comp.timestamp.clone(),
            }
        })
        .collect();
    Json(ComparisonsResponse {
        comparisons: legacy_comparisons,
    })
}
// Add a new comparison using task content
async fn add_comparison(
    State(state): State<Arc<AppState>>,
    Json(payload): Json<AddComparisonRequest>,
) -> impl IntoResponse {
    // Validate that the winner content matches one of the tasks
    if payload.winner_content != payload.task_a_content && 
       payload.winner_content != payload.task_b_content {
        return (StatusCode::BAD_REQUEST, Json(serde_json::json!({
            "error": "Winner content must match either task_a_content or task_b_content"
        }))).into_response();
    }
    // Create the new comparison with content
    let new_comparison = ContentComparison {
        task_a_content: payload.task_a_content,
        task_b_content: payload.task_b_content,
        winner_content: payload.winner_content,
        timestamp: chrono::Utc::now().to_rfc3339(),
    };
    // Add the comparison to our list
    let mut comparisons = state.comparisons.lock().unwrap();
    comparisons.push(new_comparison.clone());
    // Convert to legacy format for response
    let mut content_to_id = HashMap::new();
    content_to_id.insert(new_comparison.task_a_content.clone(), 1);
    content_to_id.insert(new_comparison.task_b_content.clone(), 2);
    let winner_id = if new_comparison.winner_content == new_comparison.task_a_content {
        1
    } else {
        2
    };
    let legacy_comparison = LegacyComparison {
        task_a_id: 1,
        task_b_id: 2,
        winner_id,
        timestamp: new_comparison.timestamp,
    };
    (StatusCode::CREATED, Json(legacy_comparison)).into_response()
}
// Get rankings using the ASAP algorithm based on task content
async fn get_rankings(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    let comparisons = state.comparisons.lock().unwrap();
    // Extract unique task contents from comparisons
    let mut unique_tasks = HashSet::new();
    for comp in comparisons.iter() {
        unique_tasks.insert(comp.task_a_content.clone());
        unique_tasks.insert(comp.task_b_content.clone());
    }
    let tasks: Vec<String> = unique_tasks.into_iter().collect();
    // If we don't have enough tasks or comparisons, return an empty response
    if tasks.len() < 2 || comparisons.is_empty() {
        return Json(RankingsResponse { rankings: Vec::new() }).into_response();
    }
    // Map task content to index
    let content_to_index: HashMap<String, usize> = tasks
        .iter()
        .enumerate()
        .map(|(i, content)| (content.clone(), i))
        .collect();
    // Convert comparisons to matrix format for ASAP
    let n = tasks.len();
    let mut m = vec![vec![0; n]; n];
    for comp in comparisons.iter() {
        if let (Some(&winner_idx), Some(&loser_idx)) = (
            content_to_index.get(&comp.winner_content),
            if comp.winner_content == comp.task_a_content {
                content_to_index.get(&comp.task_b_content)
            } else {
                content_to_index.get(&comp.task_a_content)
            },
        ) {
            m[winner_idx][loser_idx] += 1;
        }
    }
    // Run the ASAP algorithm to get ratings
    let mut asap = ASAP::new(n);
    let (_, _, ms_curr, _) = asap.run_asap(&m);
    // Create the rankings response
    let mut scores: Vec<(String, f64)> = content_to_index
        .iter()
        .map(|(content, &index)| (content.clone(), ms_curr[index]))
        .collect();
    // Sort by score (highest first)
    scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
    // Build the final rankings
    let rankings: Vec<RankedTask> = scores
        .iter()
        .enumerate()
        .map(|(rank, (content, score))| RankedTask {
            content: content.clone(),
            score: *score,
            rank: rank + 1, // 1-based ranking
        })
        .collect();
    Json(RankingsResponse { rankings }).into_response()
}
</file>

</files>
</file>

<file path="src/api.ts">
// src/api.ts
const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:3000";
export async function fetchHealth(): Promise<string> {
  const res = await fetch(`${API_BASE_URL}/healthz`);
  if (!res.ok) throw new Error('API health check failed');
  return res.text();
}
// Add more API functions as backend endpoints are defined
</file>

<file path="src/App.tsx">
import React, { useState } from 'react';
import MonacoEditor from '@monaco-editor/react';
import { fetchHealth } from './api';
function App() {
  const [markdown, setMarkdown] = useState<string>(
    '# Welcome to the Comparison Sorter App!\n\nEdit this markdown and see Monaco Editor in action.'
  );
  const [apiStatus, setApiStatus] = useState<string | null>(null);
  const [apiError, setApiError] = useState<string | null>(null);
  const checkApi = async () => {
    setApiStatus(null);
    setApiError(null);
    try {
      const status = await fetchHealth();
      setApiStatus(status);
    } catch (err: any) {
      setApiError(err.message || 'Unknown error');
    }
  };
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 p-4">
      <h1 className="text-4xl font-bold text-blue-600 mb-4">Comparison Sorter App</h1>
      <p className="text-lg text-gray-700 mb-6">React + Vite + Tailwind CSS + Monaco Editor</p>
      <div className="w-full max-w-2xl h-96 shadow-lg border border-gray-200 rounded mb-6">
        <MonacoEditor
          height="100%"
          defaultLanguage="markdown"
          value={markdown}
          onChange={value => setMarkdown(value || '')}
          options={{
            minimap: { enabled: false },
            wordWrap: 'on',
            fontSize: 16,
          }}
        />
      </div>
      <button
        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition mb-2"
        onClick={checkApi}
      >
        Test Railway Backend API
      </button>
      {apiStatus && <div className="text-green-600">API Response: {apiStatus}</div>}
      {apiError && <div className="text-red-600">API Error: {apiError}</div>}
    </div>
  );
}
export default App;
</file>

<file path="src/changes-summary.md">
# Changes Made to Use Markdown as Source of Truth

## Backend Changes

1. Removed TaskInfo storage in AppState
2. Added ContentComparison for task content-based comparisons
3. Updated API to use content-based task identification
4. Removed task registration/storage endpoints
5. Rankings now derived from comparison content

## Frontend Changes

1. Removed registeredTasks state
2. Removed all task synchronization code
3. API client now sends task content directly
4. Task ID generation now just for UI purposes
5. Simplified App.tsx to use markdown as source of truth

## Benefits

1. No more 'ghost' tasks in rankings
2. Tasks only exist in markdown
3. UI shows only what's in the markdown
4. Simple mental model - what you see is what you get
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/mp.rs">
// struct Normal<M, P, O> {}
//
//
</file>

<file path="src/plot_ci.rs">
use std::fs::File;
use std::io::Write;
fn escape_xml(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}
pub fn plot_ci(mut items: Vec<(String, f64, f64)>, filename: &str) -> std::io::Result<()> {
    // Sort items by mean in descending order
    items.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    let graph_width = 400.0;
    let left_margin = 50.0; // Reduced left margin
    let right_margin = 1200.0; // Increased right margin for labels
    let total_width = left_margin + graph_width + right_margin;
    let row_height = 20.0;
    let height = row_height * items.len() as f64 + 40.0; // Add some extra space at the bottom
    let min_mean = items
        .iter()
        .map(|&(_, m, _)| m)
        .fold(f64::INFINITY, f64::min);
    let max_mean = items
        .iter()
        .map(|&(_, m, _)| m)
        .fold(f64::NEG_INFINITY, f64::max);
    let range = max_mean - min_mean;
    let mut svg = format!(
        r#"<svg xmlns="http://www.w3.org/2000/svg" width="{}" height="{}">"#,
        total_width, height
    );
    // Add a white background
    svg.push_str(&format!(
        r#"<rect width="100%" height="100%" fill="white"/>"#
    ));
    // Add vertical line separating labels from graph
    svg.push_str(&format!(
        r#"<line x1="{}" y1="0" x2="{}" y2="{}" stroke="\#ccc" stroke-width="1"/>"#,
        left_margin, left_margin, height
    ));
    for (i, (name, mean, var)) in items.iter().enumerate() {
        let y = i as f64 * row_height + 20.0; // Add some top padding
        let x = left_margin + (graph_width * (max_mean - mean) / range);
        let ci_width = graph_width * (var.sqrt() * 1.645) / range; // 90% confidence interval
        // Add confidence interval line
        svg.push_str(&format!(
            r#"<line x1="{}" y1="{}" x2="{}" y2="{}" stroke="black" stroke-width="2"/>"#,
            x - ci_width / 2.0,
            y,
            x + ci_width / 2.0,
            y
        ));
        // Add mean point
        svg.push_str(&format!(
            r#"<circle cx="{}" cy="{}" r="4" fill="blue"/>"#,
            x, y
        ));
        // Add label to the left of the CI
        let label_x = x + ci_width / 2.0 + 10.0;
        svg.push_str(&format!(
            r#"<text x="{}" y="{}" font-family="Arial, sans-serif" font-size="14" text-anchor="start" dominant-baseline="middle">{}</text>"#,
            label_x,
            y,
            escape_xml(&truncate_text(name, 200))
        ));
    }
    svg.push_str("</svg>");
    File::create(filename)?.write_all(svg.as_bytes())?;
    Ok(())
}
fn truncate_text(s: &str, max_chars: usize) -> String {
    if s.chars().count() <= max_chars {
        s.to_string()
    } else {
        let mut truncated: String = s.chars().take(max_chars - 3).collect();
        truncated.push_str("...");
        truncated
    }
}
</file>

<file path="web/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="web/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="web/src/components/ComparisonLog.tsx">
import { useState } from 'react';
import type { Comparison } from '../utils/markdownUtils';
interface ComparisonLogProps {
  comparisons: Comparison[];
  onExport: () => void;
}
const ComparisonLog: React.FC<ComparisonLogProps> = ({ comparisons, onExport }) => {
  const [selectedComparison, setSelectedComparison] = useState<Comparison | null>(null);
  return (
    <div className="rounded-lg">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold text-gray-800 dark:text-gray-100">
          Comparison History
          <span className="ml-2 text-sm font-normal text-gray-500 dark:text-gray-400">
            ({comparisons.length} total)
          </span>
        </h2>
        <button
          onClick={onExport}
          className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-700 dark:hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          disabled={comparisons.length === 0}
        >
          <svg className="mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
          </svg>
          Export CSV
        </button>
      </div>
      {comparisons.length === 0 ? (
        <div className="flex flex-col items-center justify-center py-12 text-center">
          <div className="w-16 h-16 mb-4 text-gray-300 dark:text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
          </div>
          <h3 className="mb-1 text-lg font-medium text-gray-700 dark:text-gray-300">No comparisons yet</h3>
          <p className="text-gray-500 dark:text-gray-400 max-w-sm">
            Compare tasks to see your comparison history. This helps track how you prioritized tasks over time.
          </p>
        </div>
      ) : (
        <div className="overflow-x-auto -mx-4 sm:-mx-0">
          <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
            <thead className="bg-gray-50 dark:bg-gray-800/50">
              <tr>
                <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Date
                </th>
                <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Task A
                </th>
                <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Task B
                </th>
                <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Winner
                </th>
              </tr>
            </thead>
            <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
              {comparisons.map((comparison) => (
                <tr 
                  key={comparison.id} 
                  onClick={() => setSelectedComparison(comparison)}
                  className={`hover:bg-gray-50 dark:hover:bg-gray-750 cursor-pointer transition-colors ${
                    selectedComparison?.id === comparison.id ? 'bg-indigo-50 dark:bg-indigo-900/20' : ''
                  }`}
                >
                  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                    {comparison.timestamp.toLocaleString(undefined, { 
                      month: 'short', 
                      day: 'numeric', 
                      hour: '2-digit', 
                      minute: '2-digit'
                    })}
                  </td>
                  <td className={`px-4 py-3 text-sm ${
                    comparison.winner.id === comparison.taskA.id 
                      ? 'font-medium text-indigo-600 dark:text-indigo-400' 
                      : 'text-gray-700 dark:text-gray-300'
                  }`}>
                    {comparison.taskA.content}
                  </td>
                  <td className={`px-4 py-3 text-sm ${
                    comparison.winner.id === comparison.taskB.id 
                      ? 'font-medium text-indigo-600 dark:text-indigo-400' 
                      : 'text-gray-700 dark:text-gray-300'
                  }`}>
                    {comparison.taskB.content}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm">
                    <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400">
                      {comparison.winner.content}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};
export default ComparisonLog;
</file>

<file path="web/src/components/ComparisonView.tsx">
import React, { useState, useEffect } from 'react';
import type { Task } from '../utils/markdownUtils';
interface ComparisonViewProps {
  tasks: Task[];
  onComparisonComplete: (taskA: Task, taskB: Task, winner: Task) => void;
}
const ComparisonView: React.FC<ComparisonViewProps> = ({ tasks, onComparisonComplete }) => {
  const [currentPair, setCurrentPair] = useState<[Task, Task] | null>(null);
  const [remainingPairs, setRemainingPairs] = useState<[Task, Task][]>([]);
  const [comparisonsCount, setComparisonsCount] = useState(0);
  // Generate all possible pairs of tasks
  useEffect(() => {
    if (tasks.length < 2) return;
    const pairs: [Task, Task][] = [];
    for (let i = 0; i < tasks.length; i++) {
      for (let j = i + 1; j < tasks.length; j++) {
        pairs.push([tasks[i], tasks[j]]);
      }
    }
    // Shuffle the pairs
    const shuffledPairs = [...pairs].sort(() => Math.random() - 0.5);
    setRemainingPairs(shuffledPairs);
    // Set the first pair
    if (shuffledPairs.length > 0) {
      setCurrentPair(shuffledPairs[0]);
    }
  }, [tasks]);
  // Select the next pair after a comparison
  const getNextPair = () => {
    if (remainingPairs.length <= 1) {
      setCurrentPair(null);
      return;
    }
    const newRemainingPairs = [...remainingPairs];
    newRemainingPairs.shift(); // Remove the current pair
    setRemainingPairs(newRemainingPairs);
    setCurrentPair(newRemainingPairs[0]);
  };
  // Handle task selection
  const handleTaskSelect = (winner: Task) => {
    if (!currentPair) return;
    const [taskA, taskB] = currentPair;
    onComparisonComplete(taskA, taskB, winner);
    setComparisonsCount(prev => prev + 1);
    getNextPair();
  };
  // Handle keyboard shortcuts (1 and 2)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!currentPair) return;
      if (e.key === '1') {
        handleTaskSelect(currentPair[0]);
      } else if (e.key === '2') {
        handleTaskSelect(currentPair[1]);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [currentPair]);
  if (tasks.length < 2) {
    return (
      <div className="flex flex-col items-center justify-center p-8 text-center">
        <div className="w-16 h-16 mb-4 text-gray-300 dark:text-gray-600">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
        </div>
        <h2 className="text-xl font-bold mb-2 text-gray-700 dark:text-gray-300">Add Tasks to Compare</h2>
        <p className="text-gray-500 dark:text-gray-400 max-w-sm">
          Add at least 2 tasks in the markdown editor to begin prioritizing them.
        </p>
      </div>
    );
  }
  if (!currentPair) {
    return (
      <div className="flex flex-col items-center justify-center p-8 text-center">
        <div className="w-16 h-16 mb-4 text-emerald-500 dark:text-emerald-400">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </div>
        <h2 className="text-xl font-bold mb-2 text-gray-700 dark:text-gray-300">Comparison Complete!</h2>
        <p className="text-gray-600 dark:text-gray-400">
          You've completed {comparisonsCount} comparisons.
        </p>
        {comparisonsCount > 0 && (
          <p className="mt-4 text-sm text-gray-500 dark:text-gray-400">
            Check the Task Rankings section to see the results.
          </p>
        )}
      </div>
    );
  }
  return (
    <div className="w-full">
      <div className="text-center mb-6">
        <h2 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Which task is more important?</h2>
        <p className="text-sm text-gray-500 dark:text-gray-400">
          Press <kbd className="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs">1</kbd> for the first task, 
          <kbd className="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs ml-1">2</kbd> for the second, or click on a task.
        </p>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div 
          onClick={() => handleTaskSelect(currentPair[0])}
          className="relative rounded-xl overflow-hidden border border-indigo-100 dark:border-indigo-900 group cursor-pointer"
        >
          <div className="absolute inset-0 bg-gradient-to-br from-indigo-50 to-blue-50 dark:from-indigo-900/40 dark:to-blue-900/40 opacity-50 group-hover:opacity-100 transition-opacity"></div>
          <div className="relative p-6">
            <div className="flex items-center mb-3">
              <span className="flex-shrink-0 w-8 h-8 bg-indigo-100 dark:bg-indigo-900/50 rounded-full flex items-center justify-center text-indigo-600 dark:text-indigo-400 font-medium">1</span>
              <h3 className="ml-3 font-medium text-gray-900 dark:text-gray-100">Task A</h3>
            </div>
            <div className="text-gray-700 dark:text-gray-300 break-words">{currentPair[0].content}</div>
            <div className="absolute bottom-3 right-3 opacity-0 group-hover:opacity-100 transition-opacity">
              <span className="flex items-center justify-center w-8 h-8 bg-indigo-500 dark:bg-indigo-600 rounded-full text-white">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
              </span>
            </div>
          </div>
        </div>
        <div 
          onClick={() => handleTaskSelect(currentPair[1])}
          className="relative rounded-xl overflow-hidden border border-emerald-100 dark:border-emerald-900 group cursor-pointer"
        >
          <div className="absolute inset-0 bg-gradient-to-br from-emerald-50 to-teal-50 dark:from-emerald-900/40 dark:to-teal-900/40 opacity-50 group-hover:opacity-100 transition-opacity"></div>
          <div className="relative p-6">
            <div className="flex items-center mb-3">
              <span className="flex-shrink-0 w-8 h-8 bg-emerald-100 dark:bg-emerald-900/50 rounded-full flex items-center justify-center text-emerald-600 dark:text-emerald-400 font-medium">2</span>
              <h3 className="ml-3 font-medium text-gray-900 dark:text-gray-100">Task B</h3>
            </div>
            <div className="text-gray-700 dark:text-gray-300 break-words">{currentPair[1].content}</div>
            <div className="absolute bottom-3 right-3 opacity-0 group-hover:opacity-100 transition-opacity">
              <span className="flex items-center justify-center w-8 h-8 bg-emerald-500 dark:bg-emerald-600 rounded-full text-white">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
              </span>
            </div>
          </div>
        </div>
      </div>
      <div className="text-center text-sm text-gray-500 dark:text-gray-400">
        <span className="inline-flex items-center justify-center px-2.5 py-0.5 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-200">
          {remainingPairs.length} comparisons remaining
        </span>
      </div>
    </div>
  );
};
export default ComparisonView;
</file>

<file path="web/src/components/Editor.tsx">
import React, { useEffect, useState } from 'react';
import CodeMirror from '@uiw/react-codemirror';
import { markdown } from '@codemirror/lang-markdown';
interface EditorProps {
  value: string;
  onChange: (value: string) => void;
}
const Editor: React.FC<EditorProps> = ({ value, onChange }) => {
  const [isDarkMode, setIsDarkMode] = useState(false);
  // Detect system dark mode preference
  useEffect(() => {
    const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(darkModeQuery.matches);
    const handleChange = (e: MediaQueryListEvent) => {
      setIsDarkMode(e.matches);
    };
    darkModeQuery.addEventListener('change', handleChange);
    return () => darkModeQuery.removeEventListener('change', handleChange);
  }, []);
  return (
    <div className="h-full w-full font-mono rounded-b-lg overflow-hidden">
      <CodeMirror
        value={value}
        height="100%"
        extensions={[markdown()]}
        onChange={onChange}
        theme={isDarkMode ? 'dark' : 'light'}
        className="h-full"
        basicSetup={{
          lineNumbers: true,
          highlightActiveLine: true,
          highlightSelectionMatches: true,
          autocompletion: true,
          foldGutter: true,
          indentOnInput: true,
        }}
      />
    </div>
  );
};
export default Editor;
</file>

<file path="web/src/components/TaskRankings.tsx">
import React, { useEffect, useState } from 'react';
import type { Task, Comparison } from '../utils/markdownUtils';
import { rankingsApi } from '../utils/apiClient';
import type { RankedTask } from '../utils/apiClient';
interface TaskRankingsProps {
  tasks: Task[];
  comparisons: Comparison[];
}
const TaskRankings: React.FC<TaskRankingsProps> = ({ tasks, comparisons }) => {
  const [rankedTasks, setRankedTasks] = useState<RankedTask[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  // Fetch rankings from the API when tasks or comparisons change
  useEffect(() => {
    const fetchRankings = async () => {
      // Only fetch if we have tasks and comparisons
      if (tasks.length === 0 || comparisons.length === 0) {
        setRankedTasks([]);
        return;
      }
      setLoading(true);
      setError(null);
      try {
        const rankings = await rankingsApi.getRankings();
        // Filter rankings to only include tasks that exist in the editor
        const taskContents = tasks.map(task => task.content);
        const filteredRankings = rankings.filter(rankedTask => 
          taskContents.includes(rankedTask.content)
        );
        // Renumber ranks to be sequential after filtering
        const rerankedTasks = filteredRankings
          .sort((a, b) => a.score > b.score ? -1 : 1) // Sort by score descending
          .map((task, idx) => ({
            ...task,
            rank: idx + 1 // Re-assign ranks (1-based)
          }));
        setRankedTasks(rerankedTasks);
      } catch (err) {
        console.error('Failed to fetch rankings:', err);
        setError('Failed to fetch rankings. Using local sorting as fallback.');
        // Fallback to our local calculation if the API call fails
        const localRankedTasks = tasks.map((task, index) => ({
          ...task,
          score: 0,
          rank: index + 1
        }));
        setRankedTasks(localRankedTasks);
      } finally {
        setLoading(false);
      }
    };
    fetchRankings();
  }, [tasks, comparisons]);
  // Show loading state
  if (loading) {
    return (
      <div className="flex justify-center items-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-500 dark:border-indigo-400"></div>
        <span className="ml-3 text-gray-600 dark:text-gray-400">Loading rankings...</span>
      </div>
    );
  }
  // Show error state with fallback ranking
  if (error) {
    return (
      <div className="p-6 rounded-lg bg-red-50 dark:bg-red-900/20 text-center">
        <svg className="mx-auto h-10 w-10 text-red-500 dark:text-red-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <h3 className="text-lg font-medium text-red-800 dark:text-red-300 mb-2">Failed to load rankings</h3>
        <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
        {rankedTasks.length > 0 && (
          <div className="mt-6 overflow-y-auto max-h-[400px]">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead className="bg-gray-50 dark:bg-gray-800/50">
                <tr>
                  <th scope="col" className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Rank
                  </th>
                  <th scope="col" className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Task
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {rankedTasks.map((task) => (
                  <tr key={task.id} className="hover:bg-gray-50 dark:hover:bg-gray-750">
                    <td className="px-3 py-3 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">
                      {task.rank}
                    </td>
                    <td className="px-3 py-3 text-sm text-gray-900 dark:text-gray-100">
                      <span className={task.completed ? 'line-through text-gray-500 dark:text-gray-500' : ''}>
                        {task.content}
                      </span>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    );
  }
  // Show empty state when no tasks or comparisons
  if (tasks.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-8 text-center">
        <div className="w-16 h-16 mb-4 text-gray-300 dark:text-gray-600">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
          </svg>
        </div>
        <h3 className="text-lg font-medium text-gray-700 dark:text-gray-300 mb-1">No Tasks Yet</h3>
        <p className="text-gray-500 dark:text-gray-400 max-w-sm">
          Add tasks in the editor to start ranking them.
        </p>
      </div>
    );
  }
  if (comparisons.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-8 text-center">
        <div className="w-16 h-16 mb-4 text-gray-300 dark:text-gray-600">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3" />
          </svg>
        </div>
        <h3 className="text-lg font-medium text-gray-700 dark:text-gray-300 mb-1">No Comparisons Yet</h3>
        <p className="text-gray-500 dark:text-gray-400 max-w-sm">
          Compare tasks to generate rankings. The more comparisons you make, the more accurate the rankings will be.
        </p>
      </div>
    );
  }
  // Show rankings
  return (
    <div>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-medium text-gray-800 dark:text-gray-200">Rankings</h3>
        <div className="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400">
          <div className="flex items-center">
            <span className="inline-block w-3 h-3 rounded-full bg-emerald-400 dark:bg-emerald-500 mr-1"></span>
            <span>High</span>
          </div>
          <div className="flex items-center">
            <span className="inline-block w-3 h-3 rounded-full bg-amber-400 dark:bg-amber-500 mr-1"></span>
            <span>Medium</span>
          </div>
          <div className="flex items-center">
            <span className="inline-block w-3 h-3 rounded-full bg-red-400 dark:bg-red-500 mr-1"></span>
            <span>Low</span>
          </div>
        </div>
      </div>
      <div className="overflow-y-auto max-h-[400px] -mr-4 pr-4">
        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
          <thead className="bg-gray-50 dark:bg-gray-800/50 sticky top-0 z-10">
            <tr>
              <th scope="col" className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-16">
                Rank
              </th>
              <th scope="col" className="px-3 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                Task
              </th>
              <th scope="col" className="px-3 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-24">
                Score
              </th>
            </tr>
          </thead>
          <tbody className="bg-white dark:bg-transparent divide-y divide-gray-200 dark:divide-gray-700">
            {rankedTasks.map((task) => {
              // Determine score color based on relative position
              const scoreColorClass = 
                task.rank <= Math.ceil(rankedTasks.length / 3)
                  ? 'bg-emerald-100 text-emerald-800 dark:bg-emerald-900/30 dark:text-emerald-400'
                  : task.rank <= Math.ceil(rankedTasks.length * 2 / 3)
                    ? 'bg-amber-100 text-amber-800 dark:bg-amber-900/30 dark:text-amber-400'
                    : 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400';
              return (
                <tr key={task.id} className="hover:bg-gray-50 dark:hover:bg-gray-750 transition-colors">
                  <td className="px-3 py-3 whitespace-nowrap">
                    <div className="flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100 font-medium text-sm">
                      {task.rank}
                    </div>
                  </td>
                  <td className="px-3 py-3 text-sm text-gray-900 dark:text-gray-100">
                    <span className={task.completed ? 'line-through text-gray-500 dark:text-gray-500' : ''}>
                      {task.content}
                    </span>
                  </td>
                  <td className="px-3 py-3 whitespace-nowrap text-right">
                    <span className={`px-2 py-1 rounded-full text-xs font-medium ${scoreColorClass}`}>
                      {task.score.toFixed(2)}
                    </span>
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
};
export default TaskRankings;
</file>

<file path="web/src/components/TaskSidebar.tsx">
import React from 'react';
import { extractTasks } from '../utils/markdownUtils';
import type { Task } from '../utils/markdownUtils';
interface TaskSidebarProps {
  markdown: string;
}
const TaskSidebar: React.FC<TaskSidebarProps> = ({ markdown }) => {
  // Use the shared extractTasks function
  const tasks = extractTasks(markdown);
  return (
    <div>
      {tasks.length === 0 ? (
        <div className="flex flex-col items-center justify-center py-10 px-4 text-center">
          <div className="w-12 h-12 mb-4 text-gray-300 dark:text-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
          </div>
          <p className="text-gray-500 dark:text-gray-400">
            No tasks found. Add tasks using the <code className="text-xs bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">- [ ] Task description</code> format.
          </p>
        </div>
      ) : (
        <ul className="space-y-2 py-1">
          {tasks.map((task) => (
            <li 
              key={task.id}
              className={`group p-2 rounded-lg transition-all duration-200 hover:bg-indigo-50 dark:hover:bg-indigo-900/20 ${
                task.completed ? 'text-gray-400 dark:text-gray-500' : 'text-gray-700 dark:text-gray-300'
              }`}
            >
              <div className="flex items-start">
                <span className={`mt-0.5 w-5 h-5 border flex-shrink-0 flex items-center justify-center rounded transition-colors ${
                  task.completed 
                    ? 'bg-indigo-100 dark:bg-indigo-900/40 border-indigo-300 dark:border-indigo-700' 
                    : 'border-gray-300 dark:border-gray-600 group-hover:border-indigo-400 dark:group-hover:border-indigo-500'
                }`}>
                  {task.completed && (
                    <svg className="w-3 h-3 text-indigo-600 dark:text-indigo-400" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                  )}
                </span>
                <span className={`ml-3 ${task.completed ? 'line-through' : ''}`}>
                  {task.content}
                  {task.rank && (
                    <span className="ml-2 text-xs inline-flex items-center px-2 py-0.5 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400">
                      Rank: {task.rank} ({task.score?.toFixed(2)})
                    </span>
                  )}
                </span>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
export default TaskSidebar;
</file>

<file path="web/src/utils/markdownUtils.ts">
export interface Task {
  id: string;
  content: string;
  completed: boolean;
  line: number; // Line number in the markdown file
  rank?: number; // Optional rank from backend
  score?: number; // Optional score from backend
}
export interface Comparison {
  id: string;
  taskA: Task;
  taskB: Task;
  winner: Task;
  timestamp: Date;
}
/**
 * Extract tasks from markdown content
 * @param markdown Markdown content
 * @returns Array of Task objects
 */
export const extractTasks = (markdown: string): Task[] => {
  console.log('Extracting tasks from markdown...');
  const tasks: Task[] = [];
  const lines = markdown.split('\n');
  lines.forEach((line, index) => {
    // Match Markdown task syntax: - [ ] Task description or - [x] Task description
    const taskMatch = line.match(/^-\s\[([ x])\]\s(.+)$/);
    if (taskMatch) {
      // Check if this task already has ranking info and strip it for the task content
      let content = taskMatch[2];
      const rankingMatch = content.match(/^(.+?)\s+\|\s+Rank:\s+\d+\s+\|\s+Score:\s+[-\d.]+$/);
      if (rankingMatch) {
        // Strip ranking info from content
        content = rankingMatch[1];
        console.log(`Found task with ranking info: "${content}"`);
      }
      const taskId = `task-${index + 1}`; // Using 1-based index for task IDs to match backend
      tasks.push({
        id: taskId,
        content: content,
        completed: taskMatch[1] === 'x',
        line: index
      });
      console.log(`Extracted task: id=${taskId}, line=${index}, content="${content}"`);
    }
  });
  console.log(`Total tasks extracted: ${tasks.length}`);
  return tasks;
};
/**
 * Format comparisons data as CSV
 * @param comparisons Array of comparison objects
 * @returns CSV formatted string
 */
export const comparisonsToCSV = (comparisons: Comparison[]): string => {
  if (comparisons.length === 0) return '';
  const headers = ['Date', 'Task A', 'Task B', 'Winner'];
  const csvContent = [
    headers.join(','),
    ...comparisons.map(c => [
      new Date(c.timestamp).toISOString(),
      `"${c.taskA.content.replace(/"/g, '""')}"`,
      `"${c.taskB.content.replace(/"/g, '""')}"`,
      `"${c.winner.content.replace(/"/g, '""')}"`
    ].join(','))
  ].join('\n');
  return csvContent;
};
/**
 * Convert comparisons data to JSON
 * @param comparisons Array of comparison objects
 * @returns JSON string
 */
export const comparisonsToJSON = (comparisons: Comparison[]): string => {
  return JSON.stringify(comparisons, null, 2);
};
/**
 * Generate a unique ID
 * @returns String ID
 */
export const generateId = (): string => {
  return Math.random().toString(36).substring(2, 15) + 
    Math.random().toString(36).substring(2, 15);
};
</file>

<file path="web/src/utils/sortingUtils.ts">
import type { Task, Comparison } from './markdownUtils';
/**
 * Calculate the score for each task based on comparison results.
 * A higher score means the task was chosen more often as the winner.
 * 
 * @param tasks List of tasks
 * @param comparisons List of comparisons
 * @returns Tasks with scores, sorted from highest to lowest score
 */
export const calculateTaskRankings = (
  tasks: Task[],
  comparisons: Comparison[]
): (Task & { score: number; rank: number })[] => {
  // Initialize scores for all tasks
  const taskScores = new Map<string, number>();
  tasks.forEach(task => {
    taskScores.set(task.id, 0);
  });
  // Calculate how many times each task won
  comparisons.forEach(comparison => {
    const winnerId = comparison.winner.id;
    const currentScore = taskScores.get(winnerId) || 0;
    taskScores.set(winnerId, currentScore + 1);
  });
  // Create a sorted list of tasks with scores
  const rankedTasks = tasks
    .filter(task => taskScores.has(task.id)) // Only include tasks that have been compared
    .map(task => ({
      ...task,
      score: taskScores.get(task.id) || 0
    }))
    .sort((a, b) => b.score - a.score); // Sort by score (highest first)
  // Add rank property
  return rankedTasks.map((task, index) => ({
    ...task,
    rank: index + 1
  }));
};
/**
 * Calculate rankings using the Elo rating system, which is more
 * sophisticated than simple win counting.
 * 
 * @param tasks List of tasks
 * @param comparisons List of comparisons
 * @param kFactor The K-factor determines how much each comparison affects scores (default: 32)
 * @returns Tasks with Elo ratings, sorted from highest to lowest
 */
export const calculateEloRankings = (
  tasks: Task[],
  comparisons: Comparison[],
  kFactor: number = 32
): (Task & { eloRating: number; rank: number })[] => {
  // Initialize Elo ratings (start at 1000)
  const eloRatings = new Map<string, number>();
  tasks.forEach(task => {
    eloRatings.set(task.id, 1000);
  });
  // Process each comparison to update Elo ratings
  comparisons.forEach(comparison => {
    const taskAId = comparison.taskA.id;
    const taskBId = comparison.taskB.id;
    const winnerId = comparison.winner.id;
    // Skip if either task doesn't have a rating (should not happen normally)
    if (!eloRatings.has(taskAId) || !eloRatings.has(taskBId)) return;
    const ratingA = eloRatings.get(taskAId)!;
    const ratingB = eloRatings.get(taskBId)!;
    // Calculate expected scores (probability of winning)
    const expectedA = 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400));
    const expectedB = 1 / (1 + Math.pow(10, (ratingA - ratingB) / 400));
    // Calculate new ratings
    let newRatingA: number;
    let newRatingB: number;
    if (winnerId === taskAId) {
      // Task A won
      newRatingA = ratingA + kFactor * (1 - expectedA);
      newRatingB = ratingB + kFactor * (0 - expectedB);
    } else {
      // Task B won
      newRatingA = ratingA + kFactor * (0 - expectedA);
      newRatingB = ratingB + kFactor * (1 - expectedB);
    }
    eloRatings.set(taskAId, newRatingA);
    eloRatings.set(taskBId, newRatingB);
  });
  // Create a sorted list of tasks with Elo ratings
  const rankedTasks = tasks
    .filter(task => eloRatings.has(task.id))
    .map(task => ({
      ...task,
      eloRating: eloRatings.get(task.id) || 1000
    }))
    .sort((a, b) => b.eloRating - a.eloRating); // Sort by Elo rating (highest first)
  // Add rank property
  return rankedTasks.map((task, index) => ({
    ...task,
    rank: index + 1
  }));
};
</file>

<file path="web/src/App.css">
/* These styles will be applied by Tailwind instead */
</file>

<file path="web/src/App.tsx">
import { useState, useCallback, useEffect, useRef } from 'react';
import TaskSidebar from './components/TaskSidebar';
import ComparisonView from './components/ComparisonView';
import ComparisonLog from './components/ComparisonLog';
import TaskRankings from './components/TaskRankings';
import Editor from './components/Editor';
import { extractTasks, comparisonsToCSV, generateId } from './utils/markdownUtils';
import { comparisonsApi, healthCheck, rankingsApi, tasksApi } from './utils/apiClient';
import type { Comparison, Task } from './utils/markdownUtils';
import type { RankedTask } from './utils/apiClient';
import './App.css';
function App() {
  const [markdownContent, setMarkdownContent] = useState<string>(
    '# Welcome to the Comparison Sorter App!\n\n## Tasks\n- [ ] First task to do\n- [ ] Second task to do\n- [ ] Another important task\n- [ ] Low priority task\n\nEdit this markdown to add more tasks.'
  );
  const [activeTab, setActiveTab] = useState<'editor-compare' | 'log'>('editor-compare');
  const [comparisons, setComparisons] = useState<Comparison[]>([]);
  const [apiStatus, setApiStatus] = useState<string | null>(null);
  const [apiError, setApiError] = useState<string | null>(null);
  const [isApiConnected, setIsApiConnected] = useState<boolean>(false);
  const [rankedTasks, setRankedTasks] = useState<RankedTask[]>([]);
  const [isLoadingRankings, setIsLoadingRankings] = useState<boolean>(false);
  const [previousTasks, setPreviousTasks] = useState<string[]>([]);
  // To track when we last fetched rankings to avoid too many API calls
  const lastRankingFetchRef = useRef<number>(0);
  // To track pending markdown changes
  const markdownDebounceTimeout = useRef<number | null>(null);
  // Extract tasks from markdown - this is now the single source of truth
  const tasks = extractTasks(markdownContent);
  // Direct content matching update method
  const updateMarkdownWithRankingsByContent = async (): Promise<boolean> => {
    console.log('Content matching markdown update starting...');
    if (!isApiConnected) {
      console.error('API not connected');
      return false;
    }
    try {
      // Get latest rankings from API if we don't have recent ones
      let rankings = rankedTasks;
      if (rankedTasks.length === 0 || Date.now() - lastRankingFetchRef.current > 5000) {
        rankings = await fetchRankings();
      }
      if (rankings.length === 0) {
        console.error('No rankings available');
        return false;
      }
      // Get current task contents from the editor
      const currentTaskContents = tasks.map(task => task.content);
      // Create a map of task content to ranking data
      // Only include rankings for tasks that exist in the editor
      const contentRankMap = new Map();
      rankings
        .filter(task => currentTaskContents.includes(task.content))
        .forEach(apiTask => {
          contentRankMap.set(apiTask.content, {
            score: apiTask.score,
            rank: apiTask.rank
          });
        });
      // Track if we've made any changes to avoid unnecessary rerenders
      let hasChanges = false;
      // Update the markdown directly by matching content
      const lines = markdownContent.split('\n');
      const updatedLines = lines.map(line => {
        // Check if line is a task - optimized regex that doesn't capture optional ranking part
        const taskMatch = line.match(/^-\s\[([ x])\]\s(.+?)(?:\s+\|\s+Rank:.+)?$/);
        if (!taskMatch) return line;
        const content = taskMatch[2];
        const rankData = contentRankMap.get(content);
        if (rankData) {
          // Base task without ranking
          const baseTask = `- [${taskMatch[1]}] ${content}`;
          // New task with ranking
          const newLine = `${baseTask} | Rank: ${rankData.rank} | Score: ${rankData.score.toFixed(2)}`;
          // Only consider it a change if the line is actually different
          if (newLine !== line) {
            hasChanges = true;
            return newLine;
          }
        } else {
          // This is a task that doesn't have ranking data
          // If it has ranking information, we should remove it
          if (line.includes(' | Rank:')) {
            hasChanges = true;
            return `- [${taskMatch[1]}] ${content}`;
          }
        }
        return line;
      });
      if (!hasChanges) {
        console.log('No changes needed in markdown');
        return false;
      }
      const updatedMarkdown = updatedLines.join('\n');
      setMarkdownContent(updatedMarkdown);
      localStorage.setItem('markdown-content', updatedMarkdown);
      setApiStatus('Markdown updated with latest rankings');
      return true;
    } catch (error) {
      console.error('Error in direct update:', error);
      setApiError('Direct update failed: ' + (error.message || 'Unknown error'));
      return false;
    }
  };
  // Update markdown with rankings calls the content method
  const updateMarkdownWithRankings = async (): Promise<boolean> => {
    console.log('Starting updateMarkdownWithRankings');
    return updateMarkdownWithRankingsByContent();
  };
  // Handle changes in the editor with debouncing
  const handleEditorChange = useCallback((value: string) => {
    // Clear any pending timeout
    if (markdownDebounceTimeout.current) {
      clearTimeout(markdownDebounceTimeout.current);
    }
    // Set a new timeout to update the markdown after 500ms of inactivity
    markdownDebounceTimeout.current = setTimeout(() => {
      setMarkdownContent(value);
      localStorage.setItem('markdown-content', value);
      markdownDebounceTimeout.current = null;
    }, 500) as unknown as number;
  }, []);
  // Fetch rankings from API with throttling
  const fetchRankings = async () => {
    console.log('fetchRankings called with:', {
      isApiConnected,
      tasksLength: tasks.length,
      comparisonsLength: comparisons.length
    });
    if (!isApiConnected || tasks.length === 0 || comparisons.length === 0) {
      console.log('Skipping fetchRankings due to missing prerequisites');
      return [];
    }
    // Throttle API calls to once every 2 seconds
    const now = Date.now();
    if (now - lastRankingFetchRef.current < 2000) {
      console.log('Throttling ranking fetch, last fetch was', (now - lastRankingFetchRef.current) / 1000, 'seconds ago');
      return rankedTasks; // Return existing rankings instead of fetching
    }
    setIsLoadingRankings(true);
    lastRankingFetchRef.current = now;
    try {
      console.log('Calling rankingsApi.getRankings()');
      const rankings = await rankingsApi.getRankings();
      console.log('Rankings received from API:', rankings);
      // Filter rankings to only include tasks that exist in the editor
      const currentTaskContents = tasks.map(task => task.content);
      const filteredRankings = rankings.filter(rankedTask => 
        currentTaskContents.includes(rankedTask.content)
      );
      setRankedTasks(filteredRankings);
      setIsLoadingRankings(false);
      return filteredRankings;
    } catch (error) {
      console.error('Failed to fetch rankings from API:', error);
      setApiError('Failed to fetch rankings from API');
      setIsLoadingRankings(false);
      return [];
    }
  };
  // Add an effect to detect new tasks and update rankings accordingly
  useEffect(() => {
    // Skip if API is not connected or if we don't have any tasks
    if (!isApiConnected || tasks.length === 0) {
      return;
    }
    // Get current task contents
    const currentTaskContents = tasks.map(task => task.content);
    // Check if we have any tasks that aren't in our rankings
    const missingFromRankings = currentTaskContents.some(content => 
      !rankedTasks.some(rankedTask => rankedTask.content === content)
    );
    // Check if we have any rankings that aren't in our tasks (should be filtered out)
    const extraInRankings = rankedTasks.some(rankedTask => 
      !currentTaskContents.includes(rankedTask.content)
    );
    // If we have inconsistencies, update the rankings
    if (missingFromRankings || extraInRankings) {
      console.log('Tasks and rankings are out of sync, refreshing rankings...');
      // Add a small delay to avoid excessive updates
      const timer = setTimeout(() => {
        fetchRankings();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [tasks.length, rankedTasks.length, isApiConnected]);
  // Check API connection on mount
  useEffect(() => {
    const checkApiConnection = async () => {
      try {
        // Check if API is healthy and database is connected
        const isHealthy = await healthCheck();
        setIsApiConnected(isHealthy);
        if (isHealthy) {
          setApiStatus('Connected to API with database');
          console.log('API connected with database, loading data from API...');
          try {
            // Load data from API
            const apiComparisons = await comparisonsApi.getAllComparisons();
            console.log(`Loaded ${apiComparisons.length} comparisons from API`);
            if (apiComparisons.length > 0) {
              setComparisons(apiComparisons);
              // Also fetch rankings
              await fetchRankings();
            } else {
              console.log('No comparisons found in API, using default data');
            }
          } catch (error) {
            console.error('Failed to load data from API:', error);
            // Fall back to local storage if API fails
            setApiError('Failed to load data from API, using local storage');
            loadFromLocalStorage();
          }
        } else {
          setApiError('Using local storage (no database connection)');
          console.log('No database connection, using local storage');
          loadFromLocalStorage();
        }
      } catch (error) {
        console.error('API health check error:', error);
        setApiError('API connection error, using local storage');
        setIsApiConnected(false);
        loadFromLocalStorage();
      }
    };
    const loadFromLocalStorage = () => {
      // Load data from localStorage
      const savedMarkdown = localStorage.getItem('markdown-content');
      if (savedMarkdown) {
        setMarkdownContent(savedMarkdown);
      }
      const savedComparisons = localStorage.getItem('comparisons');
      if (savedComparisons) {
        try {
          const parsedComparisons = JSON.parse(savedComparisons);
          // Convert string dates back to Date objects
          const formattedComparisons = parsedComparisons.map((c: any) => ({
            ...c,
            timestamp: new Date(c.timestamp)
          }));
          setComparisons(formattedComparisons);
        } catch (error) {
          console.error('Failed to parse saved comparisons', error);
        }
      }
    };
    checkApiConnection();
  }, []);
  // Update rankings when comparisons change
  useEffect(() => {
    // Use a reference to track if this effect already ran for this set of comparisons
    const comparisonCount = comparisons.length;
    if (isApiConnected && comparisonCount > 0) {
      // Add a small delay to avoid rapid re-renders
      const timer = setTimeout(() => {
        fetchRankings();
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [comparisons.length, isApiConnected]); // Only depend on the length, not the whole array
  // Handle comparison completion
  const handleComparisonComplete = async (taskA: Task, taskB: Task, winner: Task) => {
    // Make sure we have complete Task objects with line property
    const completeTaskA = tasks.find(t => t.id === taskA.id) || taskA;
    const completeTaskB = tasks.find(t => t.id === taskB.id) || taskB;
    const completeWinner = tasks.find(t => t.id === winner.id) || winner;
    const newComparison: Comparison = {
      id: generateId(),
      taskA: completeTaskA,
      taskB: completeTaskB,
      winner: completeWinner,
      timestamp: new Date()
    };
    // Flag to track if we saved to API successfully
    let apiSaveSuccess = false;
    // If API is connected, send comparison to API
    if (isApiConnected) {
      try {
        console.log('Sending comparison to API...');
        await comparisonsApi.addComparison({
          taskA: completeTaskA,
          taskB: completeTaskB,
          winner: completeWinner
        });
        console.log('Comparison saved to API successfully');
        apiSaveSuccess = true;
      } catch (error) {
        console.error('Failed to save comparison to API:', error);
        setApiError('Failed to save comparison to API, using local storage');
      }
    }
    // Always save to local state and localStorage for fallback
    setComparisons(prev => {
      const updatedComparisons = [...prev, newComparison];
      localStorage.setItem('comparisons', JSON.stringify(updatedComparisons));
      return updatedComparisons;
    });
    // After saving comparison, update the rankings
    // Only if API save was successful
    if (apiSaveSuccess) {
      // Use a timeout to allow the API to update its rankings
      console.log('Scheduling automatic markdown update...');
      setTimeout(async () => {
        try {
          console.log('Automatically updating markdown with rankings after comparison...');
          const success = await updateMarkdownWithRankingsByContent();
          if (success) {
            console.log('Automatic markdown update successful');
          } else {
            console.warn('Automatic markdown update did not make any changes');
          }
        } catch (updateError) {
          console.error('Failed to auto-update markdown with rankings:', updateError);
        }
      }, 1000); // Use a slightly longer timeout to ensure the backend has processed the comparison
    }
  };
  // Handle export to CSV
  const handleExportCSV = () => {
    const csvContent = comparisonsToCSV(comparisons);
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `task-comparisons-${new Date().toISOString().split('T')[0]}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  // Detect and handle task deletions
  useEffect(() => {
    // Skip if API is not connected or if we don't have previous tasks data
    if (!isApiConnected) {
      // Update the previous tasks array for next comparison
      const currentTaskContents = tasks.map(task => task.content);
      setPreviousTasks(currentTaskContents);
      return;
    }
    const currentTaskContents = tasks.map(task => task.content);
    // Compare previous tasks with current tasks only if there's been an actual change
    // to avoid unnecessary deletion API calls
    if (previousTasks.length > 0 && 
        JSON.stringify(previousTasks.sort()) !== JSON.stringify(currentTaskContents.sort())) {
      // Find tasks that were in the previous set but not in the current set (they were deleted)
      const deletedTasks = previousTasks.filter(
        prevContent => !currentTaskContents.includes(prevContent)
      );
      // If we detected deleted tasks, remove them from the backend
      if (deletedTasks.length > 0) {
        console.log(`Detected ${deletedTasks.length} deleted tasks:`, deletedTasks);
        // Delete each removed task from the API
        const deletePromises = deletedTasks.map(async (taskContent) => {
          try {
            const result = await tasksApi.deleteTask(taskContent);
            console.log(`Task "${taskContent}" deletion result:`, result);
            return result;
          } catch (error) {
            console.error(`Failed to delete task "${taskContent}":`, error);
            return false;
          }
        });
        // When all deletions are processed, update the rankings
        Promise.all(deletePromises).then(results => {
          if (results.some(result => result)) {
            // At least one task was successfully deleted
            console.log("Successfully deleted tasks, refreshing rankings");
            fetchRankings();
          }
        });
      }
    }
    // Update the previous tasks array for next comparison
    // Only update if the content has actually changed
    if (JSON.stringify(previousTasks) !== JSON.stringify(currentTaskContents)) {
      setPreviousTasks(currentTaskContents);
    }
    // Only depend on task length changes, not the entire tasks array
    // to avoid unnecessary re-renders and API calls
  }, [tasks.length, isApiConnected]);
  // Detect and handle task additions
  useEffect(() => {
    // Skip if API is not connected
    if (!isApiConnected) {
      return;
    }
    // First, get the current task contents
    const currentTaskContents = tasks.map(task => task.content);
    // If we don't have any tasks, or our previous task list is empty, just update the previous list
    if (currentTaskContents.length === 0 || previousTasks.length === 0) {
      setPreviousTasks(currentTaskContents);
      return;
    }
    // Find new tasks that were added
    const newTasks = currentTaskContents.filter(
      content => !previousTasks.includes(content)
    );
    if (newTasks.length > 0) {
      console.log(`Detected ${newTasks.length} new tasks:`, newTasks);
      // Register each new task with the API
      const registerPromises = newTasks.map(async (taskContent) => {
        try {
          const result = await tasksApi.registerTask(taskContent);
          console.log(`Task "${taskContent}" registration result:`, result);
          return result;
        } catch (error) {
          console.error(`Failed to register task "${taskContent}":`, error);
          return false;
        }
      });
      // When all registrations are processed, update the rankings
      Promise.all(registerPromises).then(results => {
        if (results.some(result => result)) {
          // At least one task was successfully registered
          console.log("Successfully registered new tasks, refreshing rankings");
          // Add a delay to allow the backend to process the registrations
          setTimeout(() => {
            fetchRankings();
          }, 1000);
        }
      });
    }
    // Now continue with the rest of the function
  }, [tasks.length, isApiConnected]);
  return (
    <div className="flex flex-col min-h-screen w-full bg-gradient-to-br from-indigo-50 to-blue-50 dark:from-gray-900 dark:to-gray-800 text-gray-900 dark:text-gray-100">
      {/* Modern Navbar */}
      <header className="bg-white dark:bg-gray-800 shadow-sm sticky top-0 z-10 backdrop-blur-md bg-opacity-90 dark:bg-opacity-90">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center space-x-3">
              <div className="flex-shrink-0">
                <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-violet-600 to-indigo-600 flex items-center justify-center shadow-lg">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                  </svg>
                </div>
              </div>
              <h1 className="text-2xl font-bold tracking-tight text-gray-900 dark:text-white">Comparison Sorter</h1>
            </div>
            {/* API Status Indicator - modern badge */}
            {isApiConnected ? (
              <div className="flex items-center space-x-1 px-3 py-1.5 rounded-full text-xs font-medium bg-emerald-50 text-emerald-700 border border-emerald-200 dark:bg-emerald-900/30 dark:text-emerald-400 dark:border-emerald-800/50">
                <span className="relative flex h-2 w-2">
                  <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-emerald-400 opacity-75"></span>
                  <span className="relative inline-flex rounded-full h-2 w-2 bg-emerald-500"></span>
                </span>
                <span>API Connected</span>
              </div>
            ) : (
              <div className="flex items-center space-x-1 px-3 py-1.5 rounded-full text-xs font-medium bg-amber-50 text-amber-700 border border-amber-200 dark:bg-amber-900/30 dark:text-amber-400 dark:border-amber-800/50">
                <span className="relative flex h-2 w-2">
                  <span className="relative inline-flex rounded-full h-2 w-2 bg-amber-500"></span>
                </span>
                <span>Local Storage Mode</span>
              </div>
            )}
          </div>
        </div>
      </header>
      {/* Debug Info (development only) */}
      {process.env.NODE_ENV !== 'production' && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-2">
          <details className="mt-2 bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden transition-all duration-200">
            <summary className="cursor-pointer font-medium text-sm text-indigo-600 dark:text-indigo-400 px-4 py-3 focus:outline-none hover:bg-gray-50 dark:hover:bg-gray-750">
              Debug Information
            </summary>
            <div className="px-4 py-3 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900/50 text-xs space-y-3">
              <div>
                <h3 className="font-semibold text-gray-700 dark:text-gray-300">API Status:</h3>
                <pre className="mt-1 bg-white dark:bg-gray-800 p-2 rounded-md border border-gray-200 dark:border-gray-700 overflow-auto text-xs text-gray-600 dark:text-gray-400">
                  {JSON.stringify({ isApiConnected, apiStatus, apiError }, null, 2)}
                </pre>
              </div>
              <div>
                <h3 className="font-semibold text-gray-700 dark:text-gray-300">Tasks from Markdown:</h3>
                <pre className="mt-1 bg-white dark:bg-gray-800 p-2 rounded-md border border-gray-200 dark:border-gray-700 overflow-auto text-xs text-gray-600 dark:text-gray-400">
                  {JSON.stringify(tasks, null, 2)}
                </pre>
              </div>
              <div>
                <h3 className="font-semibold text-gray-700 dark:text-gray-300">Rankings:</h3>
                <pre className="mt-1 bg-white dark:bg-gray-800 p-2 rounded-md border border-gray-200 dark:border-gray-700 overflow-auto text-xs text-gray-600 dark:text-gray-400">
                  {JSON.stringify(rankedTasks, null, 2)}
                </pre>
              </div>
              <div>
                <h3 className="font-semibold text-gray-700 dark:text-gray-300">Comparisons:</h3>
                <pre className="mt-1 bg-white dark:bg-gray-800 p-2 rounded-md border border-gray-200 dark:border-gray-700 overflow-auto text-xs text-gray-600 dark:text-gray-400">
                  {JSON.stringify(comparisons.slice(0, 3), null, 2)}
                  {comparisons.length > 3 && ` ... (${comparisons.length - 3} more)`}
                </pre>
              </div>
            </div>
          </details>
        </div>
      )}
      {/* Main Content */}
      <div className="flex-grow w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Modern Navigation Tabs */}
        <div className="mb-10">
          <div className="sm:hidden">
            <select
              className="block w-full rounded-md border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-800 py-2 pl-3 pr-10 focus:border-indigo-500 dark:focus:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-300 dark:focus:ring-indigo-700 text-base"
              value={activeTab}
              onChange={(e) => setActiveTab(e.target.value as 'editor-compare' | 'log')}
            >
              <option value="editor-compare">Editor & Compare</option>
              <option value="log">Comparison Log</option>
            </select>
          </div>
          <div className="hidden sm:block">
            <div className="flex justify-center">
              <span className="inline-flex rounded-md shadow-sm p-1 bg-gray-100 dark:bg-gray-800">
                <button
                  onClick={() => setActiveTab('editor-compare')}
                  className={`px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 ${
                    activeTab === 'editor-compare'
                      ? 'bg-white dark:bg-gray-700 text-indigo-600 dark:text-indigo-400 shadow-sm'
                      : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-750'
                  }`}
                >
                  Editor & Compare
                </button>
                <button
                  onClick={() => setActiveTab('log')}
                  className={`px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 ${
                    activeTab === 'log'
                      ? 'bg-white dark:bg-gray-700 text-indigo-600 dark:text-indigo-400 shadow-sm'
                      : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-750'
                  }`}
                >
                  Comparison Log
                </button>
              </span>
            </div>
          </div>
        </div>
        {activeTab === 'editor-compare' && (
          <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
            {/* Left column: Editor and task list */}
            <div className="lg:col-span-5 space-y-6">
              <div className="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
                <div className="flex justify-between items-center px-4 py-3 bg-gray-50 dark:bg-gray-900/50 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-base font-medium text-gray-700 dark:text-gray-300">Markdown Editor</h2>
                  <div className="text-xs text-gray-500 dark:text-gray-400 italic">Supports GitHub-flavored markdown</div>
                </div>
                <div className="h-80">
                  <Editor
                    value={markdownContent}
                    onChange={handleEditorChange}
                  />
                </div>
              </div>
              <div className="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
                <div className="px-4 py-3 bg-gray-50 dark:bg-gray-900/50 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                  <h2 className="text-base font-medium text-gray-700 dark:text-gray-300">
                    Tasks <span className="ml-1 px-2 py-0.5 rounded-full text-xs bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400">{tasks.length}</span>
                  </h2>
                  <button
                    onClick={updateMarkdownWithRankings}
                    disabled={!isApiConnected || isLoadingRankings || comparisons.length === 0}
                    className={`inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md shadow-sm transition-all duration-200 ${
                      !isApiConnected || isLoadingRankings || comparisons.length === 0 
                        ? 'bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed' 
                        : 'bg-indigo-600 text-white hover:bg-indigo-700 dark:bg-indigo-700 dark:hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-gray-800'
                    }`}
                  >
                    {isLoadingRankings ? (
                      <>
                        <svg className="animate-spin -ml-1 mr-2 h-3 w-3 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Updating...
                      </>
                    ) : (
                      'Update Rankings'
                    )}
                  </button>
                </div>
                <div className="max-h-[300px] overflow-y-auto p-4">
                  <TaskSidebar markdown={markdownContent} />
                </div>
              </div>
            </div>
            {/* Right column: Comparison view and rankings */}
            <div className="lg:col-span-7 space-y-6">
              <div className="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
                <div className="px-4 py-3 bg-gray-50 dark:bg-gray-900/50 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-base font-medium text-gray-700 dark:text-gray-300">Prioritize Tasks</h2>
                </div>
                <div className="p-4">
                  <ComparisonView 
                    tasks={tasks} 
                    onComparisonComplete={handleComparisonComplete} 
                  />
                </div>
              </div>
              <div className="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
                <div className="px-4 py-3 bg-gray-50 dark:bg-gray-900/50 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-base font-medium text-gray-700 dark:text-gray-300">Task Rankings</h2>
                </div>
                <div className="p-4">
                  <TaskRankings tasks={tasks} comparisons={comparisons} />
                </div>
              </div>
            </div>
          </div>
        )}
        {activeTab === 'log' && (
          <div className="max-w-5xl mx-auto">
            <div className="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
              <div className="px-4 py-3 bg-gray-50 dark:bg-gray-900/50 border-b border-gray-200 dark:border-gray-700">
                <h2 className="text-base font-medium text-gray-700 dark:text-gray-300">Comparison History</h2>
              </div>
              <div className="p-4">
                <ComparisonLog comparisons={comparisons} onExport={handleExportCSV} />
              </div>
            </div>
          </div>
        )}
      </div>
      {/* Modern toast notifications */}
      <div className="fixed bottom-4 right-4 max-w-xs z-50 space-y-2 pointer-events-none">
        {apiStatus && (
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg border-l-4 border-emerald-500 dark:border-emerald-600 px-4 py-3 transform transition-all duration-300 ease-in-out animate-fade-in-right pointer-events-auto">
            <div className="flex items-start">
              <div className="flex-shrink-0 pt-0.5">
                <svg className="h-5 w-5 text-emerald-500 dark:text-emerald-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-gray-800 dark:text-gray-200">{apiStatus}</p>
              </div>
            </div>
          </div>
        )}
        {apiError && (
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg border-l-4 border-amber-500 dark:border-amber-600 px-4 py-3 transform transition-all duration-300 ease-in-out animate-fade-in-right pointer-events-auto">
            <div className="flex items-start">
              <div className="flex-shrink-0 pt-0.5">
                <svg className="h-5 w-5 text-amber-500 dark:text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-gray-800 dark:text-gray-200">{apiError}</p>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
export default App;
</file>

<file path="web/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
/* Base styles that don't conflict with Tailwind */
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* Remove previous default styles that were conflicting */
/* Add styles to ensure editor content is visible - these are specific enough to not be overridden */
.cm-editor {
  color: #333;
  background-color: #f9f9f9;
}
.cm-editor.cm-theme-dark {
  color: #eee;
  background-color: #1e1e1e;
}
.cm-editor .cm-content {
  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.5;
}
/* Make sure markdown task checkboxes are visible */
.cm-editor .cm-formatting-task {
  color: inherit !important;
}
/* Ensure good contrast for all themes */
.cm-editor .cm-line {
  color: inherit !important;
}
/* Fix for root taking up full viewport height */
#root {
  min-height: 100vh;
  width: 100%;
}
</file>

<file path="web/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css' // This contains the Tailwind imports
import App from './App.tsx'
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="web/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="web/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="web/Dockerfile">
FROM node:18-alpine AS build

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=build /app/dist /usr/share/nginx/html

# Copy custom nginx config to handle SPA routing
RUN rm /etc/nginx/conf.d/default.conf
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
</file>

<file path="web/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="web/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="web/netlify.toml">
[build]
  command = "yarn build"
  publish = "dist"
</file>

<file path="web/nginx.conf">
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 30d;
        add_header Cache-Control "public, no-transform";
    }

    # Don't cache HTML
    location ~* \.html$ {
        expires -1;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
    }
}
</file>

<file path="web/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="web/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```
</file>

<file path="web/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,ts,jsx,tsx}",
    "./index.html"
  ],
  darkMode: 'media', // Enable dark mode based on system preference
  theme: {
    extend: {
      colors: {
        // Add custom colors for our modern UI
        'gray-750': '#2D3748', // Custom shade between gray-700 and gray-800
      },
      animation: {
        'fade-in-right': 'fadeInRight 0.3s ease-out',
      },
      keyframes: {
        fadeInRight: {
          '0%': { opacity: '0', transform: 'translateX(10px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="web/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="web/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "emitDeclarationOnly": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="milestones.md">
- [x] Create a new frontend directory (web/)
- [ ] Initialize a Vite + React + TypeScript project [[rid::2]]
- [ ] Set up Tailwind CSS [[rid::3]]
- [ ] Install Monaco Editor and set up API client for Railway backend [[rid::1]]
- [ ] Add a basic Netlify configuration file
- [ ] Add a placeholder page and test the dev server

# Milestones for Comparison Sorter App (React + Vite Frontend, Railway Backend)

---

## 1. Project Setup

**Goal:**  
Establish a working development environment with all dependencies and basic project structure.

**Frontend:** React + Vite (TypeScript)
**Backend:** Rust web API (Axum or Actix-web) on Railway

**Tasks:**
- Initialize Git repository.
- Set up Vite + React + Tailwind CSS in `web/` directory.
- Add Monaco Editor (or CodeMirror) as a dependency.
- Set up Netlify configuration for local dev and deploy.
- Set up a new Rust web API project (e.g., with Axum or Actix-web) in a `backend/` directory.
- Initialize a Railway project for backend hosting.

**Tests:**
- `npm run dev` starts the React app and shows a placeholder page.
- Monaco/CodeMirror editor renders on the page.
- Rust API can be run locally and responds to a test request (e.g., `/healthz`).
- Netlify CLI (`netlify dev`) serves the React frontend locally.
- Railway CLI can deploy the backend and provide a public API URL.

---

## 2. Authentication (Optional, if needed)

**Goal:**  
Users can sign up, log in, and log out if authentication is required. (Otherwise, skip this step for a single-user app.)

**Tasks:**
- (Optional) Implement authentication in the backend (JWT, session, or basic auth).
- (Optional) Add login/logout UI in the React frontend.
- Store user session in app state.
- Protect main app routes from unauthenticated access if needed.

**Tests:**
- User can log in and access their data (if auth is enabled).
- User cannot access main app routes when logged out.
- User can log out and is redirected to login page.
- Invalid login shows an error.

---

## 3. Markdown File Management (via API)

**Goal:**  
Users can upload, create, view, and edit a markdown file, with changes saved via the Rust API (hosted on Railway).

**Tasks:**
- UI for uploading a markdown file (React).
- UI for creating a new markdown file (React).
- Display markdown in Monaco/CodeMirror editor (React).
- Save file content to the backend via API on change.
- Load file content from the backend on login or page load.

**Tests:**
- User can upload a markdown file and see its content in the editor.
- User can create a new file and edit it.
- Edits are saved to the backend and persist after reload.
- User sees their file after logging out and back in (if auth is enabled).

---

## 4. Task Extraction & Sidebar (Frontend)

**Goal:**  
Extract TODOs from the markdown file and display them in a sidebar.

**Tasks:**
- Parse markdown for lines like `- [ ] Task description` (in React frontend).
- Display extracted tasks in a sidebar (React).
- Update sidebar in real time as the markdown is edited.

**Tests:**
- Given a markdown file with TODOs, the sidebar lists all TODOs.
- Editing the markdown (adding/removing TODOs) updates the sidebar instantly.
- Sidebar only shows TODOs, not other markdown content.

---

## 5. Pairwise Comparison UI (Frontend + API)

**Goal:**  
Present two tasks for comparison and allow the user to select the preferred one. Log the comparison via the backend API.

**Tasks:**
- UI to display two randomly selected TODOs (React).
- Keyboard shortcuts (e.g., `1`/`2` or arrow keys) to select a winner (React).
- Button-based selection as fallback (React).
- After selection, send the comparison result to the backend API and show the next pair.

**Tests:**
- Two tasks are shown for comparison.
- Pressing `1` or `2` selects the corresponding task.
- Clicking a button selects the corresponding task.
- After selection, a new pair is shown.
- No duplicate pairs are shown until all pairs are compared (or as per algorithm).
- Each comparison is logged in the backend and can be retrieved via API.

---

## 6. Comparison Log (API)

**Goal:**  
Store and display a log of all comparisons, synced with the backend API.

**Tasks:**
- Log each comparison (task A, task B, winner, timestamp) to the backend API.
- Display comparison history in a table or list (React fetches from API).
- Allow export of log as CSV/JSON (React fetches from API).

**Tests:**
- Each comparison is recorded in the backend.
- Refreshing the page shows the full comparison history.
- Exported CSV/JSON matches the log in the backend.

---

## 7. Live Sync (Optional, Advanced)

**Goal:**  
All changes (markdown, tasks, comparisons) are synced in real time across devices/tabs (if needed).

**Tasks:**
- (Optional) Implement WebSocket or polling endpoints in the backend for live updates.
- Subscribe to changes and update UI instantly (React).
- Handle merge conflicts gracefully (last write wins, or show warning).

**Tests:**
- Editing the markdown in one tab updates the editor in another tab in real time (if live sync is implemented).
- Making a comparison in one tab updates the log in another tab instantly.
- No data is lost or duplicated during simultaneous edits.

---

## 8. UI/UX Polish & Error Handling

**Goal:**  
Ensure the app is user-friendly, responsive, and robust.

**Tasks:**
- Responsive layout for desktop and mobile (React + Tailwind).
- Loading and error states for all async actions (React).
- Clear feedback for save, sync, and errors (React).
- Accessibility (keyboard navigation, ARIA labels) (React).

**Tests:**
- App looks good and works on different screen sizes.
- All async actions show loading indicators.
- Errors (e.g., network, auth) are displayed to the user.
- App is navigable via keyboard and screen reader.

---

## 9. Deployment

**Goal:**  
App is deployed to Netlify (React frontend) and Railway (Rust backend) and works end-to-end.

**Tasks:**
- Set up Netlify site and environment variables for API URL.
- Configure build and deploy scripts for React frontend.
- Set up Railway project and deploy backend API.
- Test production build with live backend.

**Tests:**
- App is accessible at the Netlify URL and connects to the Railway API.
- All features work as in local dev.
- Environment variables are correctly set and used.

---

# Summary Table

| Milestone                | Key Tests/Acceptance Criteria                                      |
|--------------------------|--------------------------------------------------------------------|
| Project Setup            | App runs locally, editor renders, backend API responds              |
| Authentication           | User can log in/out if enabled, protected routes work               |
| Markdown File Management | Upload/create/edit file, persists via API, loads on login           |
| Task Extraction/Sidebar  | TODOs parsed and shown, updates live with edits                    |
| Pairwise Comparison UI   | Two tasks shown, keyboard/buttons work, new pair after selection   |
| Comparison Log           | Comparisons logged in backend, history shown, export works         |
| Live Sync                | Edits/comparisons sync across tabs/devices in real time (optional) |
| UI/UX Polish             | Responsive, accessible, error/loading states present               |
| Deployment               | App works on Netlify, backend on Railway, end-to-end tested        |
</file>

<file path="ratings_ci.html">
<svg xmlns="http://www.w3.org/2000/svg" width="1650" height="80"><rect width="100%" height="100%" fill="white"/><line x1="50" y1="0" x2="50" y2="80" stroke="\#ccc" stroke-width="1"/><line x1="NaN" y1="20" x2="NaN" y2="20" stroke="black" stroke-width="2"/><circle cx="NaN" cy="20" r="4" fill="blue"/><text x="NaN" y="20" font-family="Arial, sans-serif" font-size="14" text-anchor="start" dominant-baseline="middle">- [ ] Initialize a Vite + React + TypeScript project [[rid::2]]</text><line x1="NaN" y1="40" x2="NaN" y2="40" stroke="black" stroke-width="2"/><circle cx="NaN" cy="40" r="4" fill="blue"/><text x="NaN" y="40" font-family="Arial, sans-serif" font-size="14" text-anchor="start" dominant-baseline="middle">- [ ] Install Monaco Editor and set up API client for Railway backend [[rid::1]]</text></svg>
</file>

<file path="tailwind.config.js">
module.exports = {
  content: [
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="task-deletion-feature.md">
# Task Deletion Feature Implementation

## Backend Changes

1. Added a new '/tasks' endpoint with GET and DELETE methods
2. Implemented 'get_tasks' to retrieve all unique task contents from comparisons
3. Implemented 'delete_task' to remove tasks and their related comparisons

## Frontend Changes

1. Added 'tasksApi' with 'getAllTasks' and 'deleteTask' methods
2. Added task deletion detection in App.tsx using a comparison of current and previous tasks
3. Implemented automatic deletion of removed tasks from the backend
4. Added refreshing of rankings after task deletion

## How It Works

1. The app tracks the list of task contents in a 'previousTasks' state
2. When tasks are edited in the markdown, it compares the current task list with the previous one
3. If any tasks are missing from the current list (deleted), they are removed from the backend
4. All comparisons containing the deleted tasks are also removed
5. The rankings are refreshed to reflect the changes

This ensures that the markdown remains the single source of truth - when tasks are removed from the markdown, they are also removed from the backend data.
</file>

<file path=".cargo/config.toml">
# Runtime configuration for cargo
# Updated to remove the problematic patch 

[build]
rustflags = ["-C", "target-cpu=generic"]

[resolver]
version = "2"

[net]
git-fetch-with-cli = true

[registries.crates-io]
protocol = "sparse"
</file>

<file path=".sqlx/metadata.json">
{
  "db_name": "PostgreSQL",
  "statements": [
    {
      "query": "SELECT id::text, content, completed, created_at, updated_at FROM tasks ORDER BY created_at DESC",
      "describe": {
        "columns": [
          {
            "ordinal": 0,
            "name": "id",
            "type_info": "Text"
          },
          {
            "ordinal": 1,
            "name": "content",
            "type_info": "Text"
          },
          {
            "ordinal": 2,
            "name": "completed",
            "type_info": "Bool"
          },
          {
            "ordinal": 3,
            "name": "created_at",
            "type_info": "Timestamptz"
          },
          {
            "ordinal": 4,
            "name": "updated_at",
            "type_info": "Timestamptz"
          }
        ],
        "parameters": {
          "Left": []
        },
        "nullable": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    },
    {
      "query": "SELECT id::text, task_a_id::text, task_b_id::text, winner_id::text, timestamp FROM comparisons ORDER BY timestamp DESC",
      "describe": {
        "columns": [
          {
            "ordinal": 0,
            "name": "id",
            "type_info": "Text"
          },
          {
            "ordinal": 1,
            "name": "task_a_id",
            "type_info": "Text"
          },
          {
            "ordinal": 2,
            "name": "task_b_id",
            "type_info": "Text"
          },
          {
            "ordinal": 3,
            "name": "winner_id",
            "type_info": "Text"
          },
          {
            "ordinal": 4,
            "name": "timestamp",
            "type_info": "Timestamptz"
          }
        ],
        "parameters": {
          "Left": []
        },
        "nullable": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    },
    {
      "query": "SELECT id::text, content, completed, created_at, updated_at FROM tasks WHERE content = $1",
      "describe": {
        "columns": [
          {
            "ordinal": 0,
            "name": "id",
            "type_info": "Text"
          },
          {
            "ordinal": 1,
            "name": "content",
            "type_info": "Text"
          },
          {
            "ordinal": 2,
            "name": "completed",
            "type_info": "Bool"
          },
          {
            "ordinal": 3,
            "name": "created_at",
            "type_info": "Timestamptz"
          },
          {
            "ordinal": 4,
            "name": "updated_at",
            "type_info": "Timestamptz"
          }
        ],
        "parameters": {
          "Left": [
            "Text"
          ]
        },
        "nullable": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    },
    {
      "query": "INSERT INTO tasks (id, content, completed, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING id::text, content, completed, created_at, updated_at",
      "describe": {
        "columns": [
          {
            "ordinal": 0,
            "name": "id",
            "type_info": "Text"
          },
          {
            "ordinal": 1,
            "name": "content",
            "type_info": "Text"
          },
          {
            "ordinal": 2,
            "name": "completed",
            "type_info": "Bool"
          },
          {
            "ordinal": 3,
            "name": "created_at",
            "type_info": "Timestamptz"
          },
          {
            "ordinal": 4,
            "name": "updated_at",
            "type_info": "Timestamptz"
          }
        ],
        "parameters": {
          "Left": [
            "Uuid",
            "Text",
            "Bool",
            "Timestamptz",
            "Timestamptz"
          ]
        },
        "nullable": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    },
    {
      "query": "INSERT INTO comparisons (id, task_a_id, task_b_id, winner_id, timestamp) VALUES ($1, $2, $3, $4, NOW()) RETURNING id::text, task_a_id::text, task_b_id::text, winner_id::text, timestamp",
      "describe": {
        "columns": [
          {
            "ordinal": 0,
            "name": "id",
            "type_info": "Text"
          },
          {
            "ordinal": 1,
            "name": "task_a_id",
            "type_info": "Text"
          },
          {
            "ordinal": 2,
            "name": "task_b_id",
            "type_info": "Text"
          },
          {
            "ordinal": 3,
            "name": "winner_id",
            "type_info": "Text"
          },
          {
            "ordinal": 4,
            "name": "timestamp",
            "type_info": "Timestamptz"
          }
        ],
        "parameters": {
          "Left": [
            "Uuid",
            "Uuid",
            "Uuid",
            "Uuid"
          ]
        },
        "nullable": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    },
    {
      "query": "DELETE FROM tasks WHERE id = $1",
      "describe": {
        "columns": [],
        "parameters": {
          "Left": [
            "Uuid"
          ]
        },
        "nullable": []
      }
    },
    {
      "query": "DELETE FROM comparisons WHERE task_a_id = $1 OR task_b_id = $1 OR winner_id = $1",
      "describe": {
        "columns": [],
        "parameters": {
          "Left": [
            "Uuid"
          ]
        },
        "nullable": []
      }
    },
    {
      "query": "SELECT content FROM tasks WHERE id = $1",
      "describe": {
        "columns": [
          {
            "ordinal": 0,
            "name": "content",
            "type_info": "Text"
          }
        ],
        "parameters": {
          "Left": [
            "Uuid"
          ]
        },
        "nullable": [
          false
        ]
      }
    }
  ]
}
</file>

<file path=".sqlx/query-05d34e4a1c1d6dc32c47db2ce7fb5d602ec9e32ed7d5ca61dbc52afff77bfb7d.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT content FROM tasks WHERE id = $1",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "content",
        "type_info": "Text"
      }
    ],
    "parameters": {
      "Left": [
        "Uuid"
      ]
    },
    "nullable": [
      false
    ]
  },
  "hash": "05d34e4a1c1d6dc32c47db2ce7fb5d602ec9e32ed7d5ca61dbc52afff77bfb7d"
}
</file>

<file path=".sqlx/query-2bd7ebed60bdf53dba292e7c1edf30e1b03af8a27c8c27dc0741a2b5aad08dd6.json">
{
  "db_name": "PostgreSQL",
  "query": "DELETE FROM comparisons WHERE task_a_id = $1 OR task_b_id = $1 OR winner_id = $1",
  "describe": {
    "columns": [],
    "parameters": {
      "Left": [
        "Uuid"
      ]
    },
    "nullable": []
  },
  "hash": "2bd7ebed60bdf53dba292e7c1edf30e1b03af8a27c8c27dc0741a2b5aad08dd6"
}
</file>

<file path=".sqlx/query-3f7a6fc5e385f335e9d4ad5f8e7a63d3a0b5af9d0c57b07f0e43564bc6f3fd7d.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT id::text, task_a_id::text, task_b_id::text, winner_id::text, timestamp FROM comparisons ORDER BY timestamp DESC",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "task_a_id",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "task_b_id",
        "type_info": "Text"
      },
      {
        "ordinal": 3,
        "name": "winner_id",
        "type_info": "Text"
      },
      {
        "ordinal": 4,
        "name": "timestamp",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": []
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "3f7a6fc5e385f335e9d4ad5f8e7a63d3a0b5af9d0c57b07f0e43564bc6f3fd7d"
}
</file>

<file path=".sqlx/query-90cbdb92fc9c3f8308e61c08ce0cd02c8e32a5aaa2d0e44c9a32e28e6dbe5ec2.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT id::text, content, completed, created_at, updated_at FROM tasks ORDER BY created_at DESC",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "content",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "completed",
        "type_info": "Bool"
      },
      {
        "ordinal": 3,
        "name": "created_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 4,
        "name": "updated_at",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": []
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "90cbdb92fc9c3f8308e61c08ce0cd02c8e32a5aaa2d0e44c9a32e28e6dbe5ec2"
}
</file>

<file path=".sqlx/query-9b12ab57f3774b36b3c84ebce123eda5fd3ddd4a4c0f967ce05c5c801fe4c82a.json">
{
  "db_name": "PostgreSQL",
  "query": "INSERT INTO tasks (id, content, completed, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING id::text, content, completed, created_at, updated_at",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "content",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "completed",
        "type_info": "Bool"
      },
      {
        "ordinal": 3,
        "name": "created_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 4,
        "name": "updated_at",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": [
        "Uuid",
        "Text",
        "Bool",
        "Timestamptz",
        "Timestamptz"
      ]
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "9b12ab57f3774b36b3c84ebce123eda5fd3ddd4a4c0f967ce05c5c801fe4c82a"
}
</file>

<file path=".sqlx/query-a6eb2f5d63e6c1e962c27bc321fae62e4c98f36fbac6d2e9bdfeb7e0deb7c38b.json">
{
  "db_name": "PostgreSQL",
  "query": "INSERT INTO comparisons (id, task_a_id, task_b_id, winner_id, timestamp) VALUES ($1, $2, $3, $4, NOW()) RETURNING id::text, task_a_id::text, task_b_id::text, winner_id::text, timestamp",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "task_a_id",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "task_b_id",
        "type_info": "Text"
      },
      {
        "ordinal": 3,
        "name": "winner_id",
        "type_info": "Text"
      },
      {
        "ordinal": 4,
        "name": "timestamp",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": [
        "Uuid",
        "Uuid",
        "Uuid",
        "Uuid"
      ]
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "a6eb2f5d63e6c1e962c27bc321fae62e4c98f36fbac6d2e9bdfeb7e0deb7c38b"
}
</file>

<file path=".sqlx/query-b64c23f67f09db0c6c08fa15af037ec2385854e5cf3f76d3b4aec189d1d66c35.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT id::text, content, completed, created_at, updated_at FROM tasks ORDER BY created_at DESC",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "content",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "completed",
        "type_info": "Bool"
      },
      {
        "ordinal": 3,
        "name": "created_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 4,
        "name": "updated_at",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": []
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "b64c23f67f09db0c6c08fa15af037ec2385854e5cf3f76d3b4aec189d1d66c35"
}
</file>

<file path=".sqlx/query-e7c81e1aad9995ce7e57b07e2f7a2c5c7c2a1107f0227c0fbfff7f81c79d8a93.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT id::text, content, completed, created_at, updated_at FROM tasks WHERE content = $1",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Text"
      },
      {
        "ordinal": 1,
        "name": "content",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "completed",
        "type_info": "Bool"
      },
      {
        "ordinal": 3,
        "name": "created_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 4,
        "name": "updated_at",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": [
        "Text"
      ]
    },
    "nullable": [
      false,
      false,
      false,
      false,
      false
    ]
  },
  "hash": "e7c81e1aad9995ce7e57b07e2f7a2c5c7c2a1107f0227c0fbfff7f81c79d8a93"
}
</file>

<file path=".sqlx/query-f7a91c3f3bbe3b7b84c5a8d9c2f13a0a7b8d05ade7d8094c6bd0de7dd7f03e26.json">
{
  "db_name": "PostgreSQL",
  "query": "DELETE FROM tasks WHERE id = $1",
  "describe": {
    "columns": [],
    "parameters": {
      "Left": [
        "Uuid"
      ]
    },
    "nullable": []
  },
  "hash": "f7a91c3f3bbe3b7b84c5a8d9c2f13a0a7b8d05ade7d8094c6bd0de7dd7f03e26"
}
</file>

<file path="migrations/20240701000000_create_tables.sql">
-- Create tasks table
CREATE TABLE IF NOT EXISTS tasks (
    id UUID PRIMARY KEY,
    content TEXT NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
-- Create comparisons table
CREATE TABLE IF NOT EXISTS comparisons (
    id UUID PRIMARY KEY,
    task_a_id UUID NOT NULL REFERENCES tasks(id),
    task_b_id UUID NOT NULL REFERENCES tasks(id),
    winner_id UUID NOT NULL REFERENCES tasks(id),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_tasks_content ON tasks(content);
CREATE INDEX IF NOT EXISTS idx_comparisons_task_a_id ON comparisons(task_a_id);
CREATE INDEX IF NOT EXISTS idx_comparisons_task_b_id ON comparisons(task_b_id);
CREATE INDEX IF NOT EXISTS idx_comparisons_winner_id ON comparisons(winner_id);
CREATE INDEX IF NOT EXISTS idx_comparisons_timestamp ON comparisons(timestamp);
</file>

<file path="migrations/20250511_create_tables.sql">
-- Create tasks table
CREATE TABLE IF NOT EXISTS tasks (
    id UUID PRIMARY KEY,
    content TEXT NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
-- Create comparisons table
CREATE TABLE IF NOT EXISTS comparisons (
    id UUID PRIMARY KEY,
    task_a_id UUID NOT NULL REFERENCES tasks(id),
    task_b_id UUID NOT NULL REFERENCES tasks(id),
    winner_id UUID NOT NULL REFERENCES tasks(id),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT winner_is_task_a_or_b CHECK (winner_id = task_a_id OR winner_id = task_b_id)
);
</file>

<file path="scripts/db.sh">
#!/bin/bash
# Database operations script for the todo-sorter application
set -e
# Load environment variables
if [ -f .env ]; then
  export $(grep -v '^#' .env | xargs)
fi
# Check if DATABASE_URL is set
if [ -z "$DATABASE_URL" ]; then
  echo "Error: DATABASE_URL environment variable is not set."
  echo "Please create a .env file with DATABASE_URL or set it manually."
  exit 1
fi
# Command line argument
CMD=$1
case $CMD in
  create)
    echo "Creating database..."
    # Extract database name from DATABASE_URL
    DB_NAME=$(echo $DATABASE_URL | sed -e 's/.*\///')
    if [ -z "$DB_NAME" ]; then
      echo "Error: Could not extract database name from DATABASE_URL."
      exit 1
    fi
    # Create the database
    createdb $DB_NAME || echo "Database already exists or could not be created."
    echo "Database creation attempted."
    ;;
  migrate)
    echo "Running migrations..."
    # Create migrations directory if it doesn't exist
    mkdir -p migrations
    # Check if there are migration files
    if [ ! "$(ls -A migrations)" ]; then
      echo "No migration files found in migrations directory."
      exit 1
    fi
    # Run each SQL file in the migrations directory
    for file in migrations/*.sql; do
      echo "Applying migration: $file"
      psql $DATABASE_URL -f $file
    done
    echo "Migrations completed."
    ;;
  reset)
    echo "Resetting database..."
    # Extract database name from DATABASE_URL
    DB_NAME=$(echo $DATABASE_URL | sed -e 's/.*\///')
    if [ -z "$DB_NAME" ]; then
      echo "Error: Could not extract database name from DATABASE_URL."
      exit 1
    fi
    # Drop and recreate the database
    dropdb --if-exists $DB_NAME
    createdb $DB_NAME
    # Run migrations
    $0 migrate
    echo "Database reset completed."
    ;;
  *)
    echo "Usage: $0 <command>"
    echo "Commands:"
    echo "  create  - Create the database"
    echo "  migrate - Run all migrations"
    echo "  reset   - Reset the database (drop, create, migrate)"
    exit 1
    ;;
esac
exit 0
</file>

<file path="scripts/prepare.sh">
#!/bin/bash
set -e
# Ensure DATABASE_URL is set
if [ -z "$DATABASE_URL" ]; then
    echo "DATABASE_URL must be set"
    exit 1
fi
# Generate query metadata
echo "Generating SQLx query metadata for offline mode..."
cargo sqlx prepare -- --lib
echo "Done! SQLx can now be used in offline mode."
</file>

<file path="src/asap_cpu.rs">
use libm::{erf, erfc, exp};
use std::f64::consts::PI;
use std::collections::{HashMap, HashSet};
// perf ideas:
// - use selective EIG a la (https://arxiv.org/abs/2004.05691) (~only eval posterior on pairs with closeish ratings)
// - dynamically set threshold based on gradient of KL divergence and maybe best known EIG?
//   - compute gradients of element posteriors by other element posteriors & use that to propagate gradients?
//   - doable with autodiff i think, just backprop on KL div & use gradients of posteriors as thresholds
// - prio queue for updates in message passing by magnitude of update?
// Simple TrueSkill implementation for content-based task comparisons
pub struct ASAP {
    // Maps task content to ratings
    pub task_ratings: HashMap<String, f64>,
    // Tracks comparison history
    comparisons: Vec<(String, String, usize)>, // (taskA, taskB, winner: 0 for A, 1 for B)
    // Baseline variance
    pub variance: f64,
}
impl ASAP {
    pub fn new() -> Self {
        ASAP {
            task_ratings: HashMap::new(),
            comparisons: Vec::new(),
            variance: 1.0,
        }
    }
    // Add a comparison with task content strings
    pub fn add_comparison(&mut self, task_a: &str, task_b: &str, winner: usize) {
        // Initialize ratings if these are new tasks
        if !self.task_ratings.contains_key(task_a) {
            self.task_ratings.insert(task_a.to_string(), 0.0);
        }
        if !self.task_ratings.contains_key(task_b) {
            self.task_ratings.insert(task_b.to_string(), 0.0);
        }
        // Store the comparison
        self.comparisons.push((task_a.to_string(), task_b.to_string(), winner));
        // Update ratings
        self.update_ratings();
    }
    // Get all ratings
    pub fn ratings(&self) -> Vec<(String, f64)> {
        self.task_ratings
            .iter()
            .map(|(content, score)| (content.clone(), *score))
            .collect()
    }
    // Update ratings using simplified TrueSkill
    fn update_ratings(&mut self) {
        // Reset all ratings to zero
        for rating in self.task_ratings.values_mut() {
            *rating = 0.0;
        }
        // Apply each comparison to update ratings
        for (task_a, task_b, winner) in &self.comparisons {
            // Fix double mutable borrow by copying values first, then updating
            let task_a_clone = task_a.clone();
            let task_b_clone = task_b.clone();
            let winner_value = *winner;
            // Simple update rule: winner gains 1 point, loser loses 1 point
            if winner_value == 0 {
                if let Some(rating) = self.task_ratings.get_mut(&task_a_clone) {
                    *rating += 1.0;
                }
                if let Some(rating) = self.task_ratings.get_mut(&task_b_clone) {
                    *rating -= 1.0;
                }
            } else {
                if let Some(rating) = self.task_ratings.get_mut(&task_a_clone) {
                    *rating -= 1.0;
                }
                if let Some(rating) = self.task_ratings.get_mut(&task_b_clone) {
                    *rating += 1.0;
                }
            }
        }
        // Normalize ratings to have mean 0
        if !self.task_ratings.is_empty() {
            let mean: f64 = self.task_ratings.values().sum::<f64>() / self.task_ratings.len() as f64;
            for rating in self.task_ratings.values_mut() {
                *rating -= mean;
            }
        }
    }
}
struct FastUsizeSet {
    set: Vec<bool>,
    vec: Vec<usize>,
}
impl FastUsizeSet {
    fn new(n: usize) -> Self {
        FastUsizeSet {
            set: vec![false; n],
            vec: Vec::new(),
        }
    }
    fn add(&mut self, i: usize) {
        if self.set[i] {
            return;
        }
        self.set[i] = true;
        self.vec.push(i);
    }
    fn pop(&mut self) -> Option<usize> {
        let i = self.vec.pop();
        if let Some(i) = i {
            self.set[i] = false;
        }
        i
    }
}
struct TrueSkillSolver {
    n: usize,
    ms: Vec<f64>,
    vs: Vec<f64>,
    mgs: Vec<[f64; 2]>,
    pgs: Vec<[f64; 2]>,
    var_to_cmps0: Vec<Vec<usize>>,
    var_to_cmps1: Vec<Vec<usize>>,
    g: Vec<[usize; 2]>,
}
impl TrueSkillSolver {
    pub fn new(n: usize) -> Self {
        TrueSkillSolver {
            n,
            ms: vec![0.0; n],
            vs: vec![0.5; n],
            mgs: Vec::new(),
            pgs: Vec::new(),
            var_to_cmps0: vec![vec![]; n],
            var_to_cmps1: vec![vec![]; n],
            g: Vec::new(),
        }
    }
    fn push_many(&mut self, g: &[[usize; 2]]) {
        for &[a, b] in g {
            self.push_cmp(a, b);
        }
    }
    fn push_cmp(&mut self, i: usize, j: usize) {
        self.pgs.push([0.0; 2]);
        self.mgs.push([0.0; 2]);
        self.g.push([i, j]);
        let id = self.pgs.len() - 1;
        self.var_to_cmps0[i].push(id);
        self.var_to_cmps1[j].push(id);
    }
    fn pop_cmp(&mut self, i: usize, j: usize) {
        self.pgs.pop();
        self.mgs.pop();
        self.g.pop();
        let id = self.pgs.len();
        self.var_to_cmps0[i].retain(|&x| x != id);
        self.var_to_cmps1[j].retain(|&x| x != id);
    }
    // pub fn solve_with_cmp(
    //     &mut self,
    //     g: &[[usize; 2]],
    //     num_iters: usize,
    //     cmp: (usize, usize),
    // ) -> (Vec<f64>, Vec<f64>) {
    // }
    //
    pub fn solve(&mut self, save: bool) -> (Vec<f64>, Vec<f64>) {
        let mut todo_vars = FastUsizeSet::new(self.n);
        let mut todo_cmps = FastUsizeSet::new(self.g.len());
        for p in 0..self.n {
            todo_vars.add(p);
        }
        for j in 0..self.g.len() {
            todo_cmps.add(j);
        }
        self._solve(todo_vars, todo_cmps, save, 0.001)
    }
    pub fn solve_one(&mut self, cmp: (usize, usize)) -> (Vec<f64>, Vec<f64>) {
        self.push_cmp(cmp.0, cmp.1);
        let mut todo_vars = FastUsizeSet::new(self.n);
        let mut todo_cmps = FastUsizeSet::new(self.g.len());
        todo_vars.add(cmp.0);
        todo_vars.add(cmp.1);
        todo_cmps.add(self.g.len() - 1);
        // TODO could run top k candidates again with a lower threshold
        let r = self._solve(todo_vars, todo_cmps, false, 0.1);
        self.pop_cmp(cmp.0, cmp.1);
        r
    }
    pub fn _solve(
        &mut self,
        mut todo_vars: FastUsizeSet,
        mut todo_cmps: FastUsizeSet,
        save: bool,
        threshold: f64,
    ) -> (Vec<f64>, Vec<f64>) {
        let mut pgs = self.pgs.clone();
        let mut mgs = self.mgs.clone();
        let mut ps: Vec<f64> = self.vs.iter().map(|&v| 1.0 / v).collect();
        let mut ms = self.ms.clone();
        let mut sum_pgs_mgs = vec![0.0; self.n];
        let mut sum_pgs = vec![0.0; self.n];
        // assert!(n_cmps == pgs.len());
        // assert!(n_cmps == mgs.len());
        // assert!(n_cmps == self.g.len());
        assert!(self.n == sum_pgs.len());
        assert!(self.n == sum_pgs_mgs.len());
        assert!(self.n == ps.len());
        assert!(self.n == ms.len());
        let g = &self.g;
        for _i in 0..1000 {
            // println!("iter {}, todo_cmps {}", _i, todo_cmps.vec.len());
            if todo_cmps.vec.len() == 0 {
                break;
            }
            while let Some(j) = todo_cmps.pop() {
                // TODO to avoid bounds check but can't use nightly bc raj :(
                // unsafe {
                //     std::intrinsics::assume(g[j][0] < self.n && g[j][1] < self.n);
                //     std::intrinsics::assume(j < self.g.len());
                // }
                // unsafe {
                //     std::intrinsics::assume(g[j][0] < self.n && g[j][1] < self.n);
                // }
                let psg0 = ps[g[j][0]] - pgs[j][0];
                let psg1 = ps[g[j][1]] - pgs[j][1];
                let msg0 = (ps[g[j][0]] * ms[g[j][0]] - pgs[j][0] * mgs[j][0]) / psg0;
                let msg1 = (ps[g[j][1]] * ms[g[j][1]] - pgs[j][1] * mgs[j][1]) / psg1;
                let vgt = 1.0 + 1.0 / psg0 + 1.0 / psg1;
                let mgt = msg0 - msg1;
                let (ps_val, lmb) = psi_lamb(mgt / vgt.sqrt());
                let mt = mgt + vgt.sqrt() * ps_val;
                let pt = 1.0 / (vgt * (1.0 - lmb));
                let ptg = pt - 1.0 / vgt;
                let mtg = (mt * pt - mgt / vgt) / (ptg + f64::EPSILON);
                pgs[j][0] = 1.0 / (1.0 + 1.0 / ptg + 1.0 / psg1);
                pgs[j][1] = 1.0 / (1.0 + 1.0 / ptg + 1.0 / psg0);
                mgs[j][0] = msg1 + mtg;
                mgs[j][1] = msg0 - mtg;
                todo_vars.add(g[j][0]);
                todo_vars.add(g[j][1]);
            }
            while let Some(p) = todo_vars.pop() {
                sum_pgs[p] = 0.0;
                sum_pgs_mgs[p] = 0.0;
                for &i in &self.var_to_cmps0[p] {
                    sum_pgs[p] += pgs[i][0];
                    sum_pgs_mgs[p] += pgs[i][0] * mgs[i][0];
                }
                for &i in &self.var_to_cmps1[p] {
                    sum_pgs[p] += pgs[i][1];
                    sum_pgs_mgs[p] += pgs[i][1] * mgs[i][1];
                }
                let ps_ = 0.02 + sum_pgs[p];
                let ms_ = sum_pgs_mgs[p] / ps_;
                if (ms_ - ms[p]).abs() > threshold || (ps_ - ps[p]).abs() > threshold {
                    // println!("p {} ms {} -> {} ps {} -> {}", p, ms[p], ms_, ps[p], ps_);
                    for &i in &self.var_to_cmps0[p] {
                        todo_cmps.add(i);
                    }
                    for &i in &self.var_to_cmps1[p] {
                        todo_cmps.add(i);
                    }
                }
                ps[p] = ps_;
                ms[p] = ms_;
            }
        }
        if ps.iter().any(|&p| p.is_nan()) || ms.iter().any(|&m| m.is_nan()) {
            panic!("NaN in ps/ms: ps: {:?}\nms: {:?}", ps, ms);
        }
        if save {
            self.vs = ps.iter().map(|&p| 1.0 / p).collect();
            self.ms = ms.clone();
            self.pgs = pgs;
            self.mgs = mgs;
        }
        (ms, ps.iter().map(|&p| 1.0 / p).collect())
    }
}
// Helper functions
fn kl_divergence(mean_1: &[f64], var_1: &[f64], mean_2: &[f64], var_2: &[f64]) -> f64 {
    0.5 * (var_2.iter().map(|&x| x.ln()).sum::<f64>() - var_1.iter().map(|&x| x.ln()).sum::<f64>()
        + var_1
            .iter()
            .zip(var_2.iter())
            .map(|(&v1, &v2)| v1 / v2)
            .sum::<f64>()
        + mean_1
            .iter()
            .zip(mean_2.iter())
            .zip(var_2.iter())
            .map(|((&m1, &m2), &v2)| (m2 - m1).powi(2) / v2)
            .sum::<f64>()
        - mean_1.len() as f64)
}
// too slow :(
// TODO could use simd w/ sleef for erf
fn kl_div_pairs(mean_1: &[f64], var_1: &[f64], mean_2: &[f64], var_2: &[f64]) -> f64 {
    let mut sorted_ixs = (0..mean_1.len()).collect::<Vec<_>>();
    sorted_ixs.sort_by(|&i, &j| mean_1[i].partial_cmp(&mean_1[j]).unwrap());
    let mut kl = 0.0;
    for i in 0..mean_1.len() {
        let m1l = mean_1[i];
        let v1l = var_1[i];
        let m2l = mean_2[i];
        let v2l = var_2[i];
        if (m1l - m2l).abs() < 1e-6 && (v1l - v2l).abs() < 1e-6 {
            continue;
        }
        // only compare closest 4 items to each i
        // FIXME need to sort by mean first
        for j in (i.saturating_sub(2))..(i + 3).min(mean_1.len()) {
            let m1r = mean_1[j];
            let v1r = var_1[j];
            let m2r = mean_2[j];
            let v2r = var_2[j];
            let v1_sum = 1.0 + v1l + v1r;
            let v2_sum = 1.0 + v2l + v2r;
            // TODO get q from prob cmps
            let p = ndtr((m1l - m1r) / v1_sum.sqrt());
            let q = ndtr((m2l - m2r) / v2_sum.sqrt());
            kl += p * (p / q).ln();
            // kl += (1.0 - p) * ((1.0 - p) / (1.0 - q)).ln();
        }
    }
    kl
}
fn ndtr(a: f64) -> f64 {
    if a.is_nan() {
        return f64::NAN;
    }
    let x = a * (1.0 / 2.0_f64.sqrt());
    let z = x.abs();
    if z < (1.0 / 2.0_f64.sqrt()) {
        0.5 + 0.5 * erf(x)
    } else {
        let y = 0.5 * erfc(z);
        if x > 0.0 {
            1.0 - y
        } else {
            y
        }
    }
}
fn psi_lamb(x: f64) -> (f64, f64) {
    let p = exp(-x * x / 2.0) / (2.0 * PI).sqrt();
    let c = ndtr(x);
    let ps = p / c;
    (ps, ps * (ps + x))
}
</file>

<file path="src/main.rs">
// #![feature(let_chains)]
// #![feature(core_intrinsics)]
mod asap_cpu;
mod mp;
mod plot_ci;
pub mod plot_ratings;
mod sorter;
mod web_service;
mod db;
#[tokio::main]
async fn main() {
    // Load environment variables
    dotenv::dotenv().ok();
    // Check for command line arguments
    let args: Vec<String> = std::env::args().collect();
    // If "api" argument is provided, run the web service
    if args.len() > 1 && args[1] == "api" {
        println!("Starting API server...");
        web_service::run_web_service().await;
    } else {
        // Otherwise, run the original sorter CLI
        if let Err(e) = sorter::main() {
            eprintln!("Error: {}", e);
        }
    }
}
</file>

<file path="src/plot_ratings.rs">
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::process::Command;
// fn rating_to_color(range: f64, rating: f64) -> String {
//     // let clamped_rating = rating.max(-2.0).min(2.0);
//     color_from_norm(normalized)
// }
fn color_from_norm(norm: f64) -> String {
    if norm < 0.5 {
        let r = 255;
        let g = (255.0 * (norm * 2.0)) as u8;
        format!("#{:02X}{:02X}00", r, g)
    } else {
        let r = (255.0 * ((1.0 - norm) * 2.0)) as u8;
        let g = 255;
        format!("#{:02X}{:02X}00", r, g)
    }
}
fn edge_color_from_norm(norm: f64) -> String {
    let intensity = (255.0 * (1.0 - norm)) as u8;
    format!("#{:02X}{:02X}{:02X}", intensity, intensity, intensity)
}
fn dfs(
    edges: &HashMap<usize, Vec<usize>>,
    from: usize,
    visited: &mut HashSet<usize>,
    map: &HashMap<(usize, usize), f64>,
    ok: &impl Fn(&f64) -> bool,
) {
    if !visited.insert(from) {
        return;
    }
    for to in edges.get(&from).unwrap_or(&vec![]) {
        if ok(map.get(&(from, *to)).unwrap()) {
            dfs(edges, *to, visited, map, ok);
        }
    }
}
fn transitive_reduction(edges: &mut HashMap<(usize, usize), f64>, ok: &impl Fn(&f64) -> bool) {
    // let mut edges_to_remove = Vec::new();
    let mut map: HashMap<usize, Vec<usize>> = HashMap::new();
    let mut nodes: Vec<usize> = edges.keys().map(|(x, _)| *x).collect();
    nodes.sort();
    for (from, to) in edges.keys() {
        map.entry(*from).or_insert_with(Vec::new).push(*to);
    }
    let mut edges_to_remove = HashSet::new();
    let mut dfs_buf: HashSet<usize> = HashSet::new();
    for n1 in nodes.iter() {
        for n2 in map.get(n1).unwrap_or(&vec![]) {
            if edges_to_remove.contains(n2) {
                continue;
            }
            dfs_buf.insert(*n1);
            dfs(&map, *n2, &mut dfs_buf, &edges, ok);
            for n3 in dfs_buf.iter() {
                if n2 == n3 || n1 == n3 {
                    continue;
                }
                edges_to_remove.insert(*n3);
            }
            dfs_buf.clear();
            // }
        }
        for y in edges_to_remove.iter() {
            edges.remove(&(*n1, *y));
            map.get_mut(n1)
                .unwrap()
                .retain(|z| !edges_to_remove.contains(z));
        }
        edges_to_remove.clear();
    }
}
pub fn plot_ratings(
    input_file: &str,
    output_file: &str,
    ms_curr: &[f64],
    id_to_index: &HashMap<usize, usize>,
    prob: &[Vec<f64>],
) -> io::Result<()> {
    let print = false;
    // let mut dot_content = String::from("digraph {\n  rankdir=LR;\nnewrank=true;\n");
    let mut dot_content =
        // String::from("digraph {\n  rankdir=LR;\nTBbalance=\"max\"\nratio=\"compress\"\n");
        // String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nranksep=\"0.1\"\nsplines=line\n");
        // String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nmargin=0\nnodesep=\"0.02\"\nranksep=\"0.05\"\nconcentrate=true\n");
        String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nmargin=0\nnodesep=\"0.02\"\nranksep=\"0.05\"\n");
    // String::from("digraph {\n  rankdir=LR;\nratio=\"0.7\"\nmargin=0\nnodesep=\"0.02\"\nranksep=\"0.05\"\n");
    // \nranksep=\"0.1\"\n");
    let rating_min = ms_curr.iter().fold(f64::INFINITY, |acc, &p| acc.min(p));
    let rating_max = ms_curr.iter().fold(f64::NEG_INFINITY, |acc, &p| acc.max(p));
    let rating_range = rating_max - rating_min;
    if print {
        println!("{:?}", (rating_min, rating_max, rating_range));
    }
    for (id, idx) in id_to_index.iter() {
        let rating = ms_curr[*idx];
        let color = color_from_norm((rating - rating_min) / rating_range);
        dot_content.push_str(&format!(
            // "  {} [label=\"{}\", style=filled, fillcolor=\"{}\"];\n",
            "  {} [label=\"{}\", style=filled, fillcolor=\"{}\"];\n",
            id, id, color
        ));
    }
    let Ok(file) = File::open(input_file) else {
        return Ok(());
    };
    let reader = io::BufReader::new(file);
    let mut edges: HashMap<(usize, usize), f64> = HashMap::new();
    for line in reader.lines() {
        let line = line?;
        let parts: Vec<&str> = line.split(',').collect();
        if parts.len() == 2 {
            let from = parts[0].parse::<usize>().unwrap();
            let to = parts[1].parse::<usize>().unwrap();
            if id_to_index.contains_key(&from) && id_to_index.contains_key(&to) {
                // Default to 0.75 if prob is empty
                let p = if !prob.is_empty() {
                    prob[id_to_index[&from]][id_to_index[&to]]
                } else {
                    0.75 // Default value if prob is empty
                };
                edges.insert((from, to), p);
            }
        }
    }
    transitive_reduction(&mut edges, &|p| *p > 0.5);
    transitive_reduction(&mut edges, &|p| *p < 0.5);
    // transitive_reduction(&mut edges, &|p| *p > 0.4);
    // transitive_reduction(&mut edges, &|p| *p < 0.6);
    // transitive_reduction(&mut edges, &|_| true);
    if print {
        println!("Edges after transitive reduction: {:?}", edges.len());
    }
    for ((from, to), &p) in edges.iter() {
        // let d = if ms_map[&from] < ms_map[&to] {
        //     ((ms_map[&from] - ms_map[&to]) / 0.3).floor()
        // } else {
        //     ((ms_map[&from] - ms_map[&to]) / 0.2).floor().max(1.0)
        // };
        // TODO maybe also use variance here?
        // maybe use cmp prob?
        // println!("{:?}", p);
        // let d = ((p - 0.5) * 2.0).powf(3.0);
        // let d = ms_map[&to] - ms_map[&from];
        // let d =
        dot_content.push_str(&format!(
            "  {} -> {} [color=\"{}\"{}];\n",
            &from,
            &to,
            edge_color_from_norm(p),
            if p > 0.5 {
                // ",weight=10"
                ""
            } else if p > 0.45 {
                ",minlen=0"
            } else if p > 0.35 {
                ",minlen=0,weight=0"
                // ",minlen=0,weight=1"
            } else {
                ",minlen=0,constraint=false"
            }
        ));
        // dot_content.push_str(&format!("  {} -> {} [len={}];\n", &from, &to, d));
        // let w = p * 0.3;
        // if ms_map[&from] < ms_map[&to] {
        //     let d = ((ms_map[&from] - ms_map[&to]) * w).ceil();
        //     dot_content.push_str(&format!("  {} -> {} [minlen={}];\n", &from, &to, d));
        //     // dot_content.push_str(&format!("  {} -> {} [minlen=0];\n", &from, &to));
        // } else {
        //     let d = ((ms_map[&from] - ms_map[&to]) * (w / 1.0)).ceil();
        //     dot_content.push_str(&format!("  {} -> {} [minlen={}];\n", &from, &to, d));
        // }
    }
    dot_content.push_str("}\n");
    let output_dot = format!("{}.dot", output_file);
    let output_png = format!("{}.png", output_file);
    // Save the dot file
    std::fs::write(&output_dot, &dot_content)?;
    if print {
        println!("Dot file saved as {}", output_dot);
    }
    // Generate PNG from dot file
    // let command = format!("tred {} | dot -Tpng -o {}", output_dot, output_png);
    let command = format!("dot -Tpng {} -o {}", output_dot, output_png);
    // let command = format!("tred {} | fdp -Tpng -o {}", output_dot, output_png);
    let out = Command::new("sh").arg("-c").arg(&command).output()?;
    if print {
        io::stdout().write_all(&out.stdout)?;
        io::stderr().write_all(&out.stderr)?;
        println!("Graph saved as {}", output_png);
    }
    Ok(())
}
</file>

<file path="src/sorter.rs">
use rand::Rng;
use tuple_map::TupleMap2;
use crate::asap_cpu::ASAP;
use crate::plot_ci::plot_ci;
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::process::Command;
use std::thread;
const EMOJIS: &[&str] = &["📅", "⏳", "✅"];
pub fn main() -> io::Result<()> {
    let mut args = std::env::args();
    args.next();
    let dir = args.next().unwrap();
    std::env::set_current_dir(dir.clone())?;
    println!(
        "dir: {} (should be = {})",
        std::env::current_dir()?.display(),
        dir
    );
    loop {
        run()?
    }
}
fn run() -> io::Result<()> {
    let (mut with_rid, mut without_rid) = get_todos()?;
    if without_rid.is_empty() && with_rid.is_empty() {
        println!("No todos found");
        return Ok(());
    }
    let comparisons = if let Ok(file) = File::open("ratings.log") {
        let fr = io::BufReader::new(&file);
        fr.lines()
            .filter_map(|line| {
                let line = line.ok()?;
                if let [i, j] = line
                    .split(',')
                    .filter_map(|s| s.parse().ok())
                    .filter(|&i| with_rid.contains_key(&i))
                    .collect::<Vec<_>>()[..]
                {
                    Some((i, j))
                } else {
                    None
                }
            })
            .collect()
    } else {
        Vec::new()
    };
    let mut id_to_index: HashMap<_, _> = with_rid
        .iter()
        .enumerate()
        .map(|(i, (&id, _))| (id, i))
        .collect();
    let mut index_to_id: HashMap<_, _> = id_to_index.iter().map(|(&k, &v)| (v, k)).collect();
    let n = with_rid.len() + if without_rid.is_empty() { 0 } else { 1 };
    let mut m = vec![vec![0; n]; n];
    for &(i, j) in &comparisons {
        if id_to_index.contains_key(&i) && id_to_index.contains_key(&j) {
            m[id_to_index[&i]][id_to_index[&j]] += 1;
        }
    }
    // println!("m: {:?}", m);
    // println!("n: {}", n);
    let mut asap = ASAP::new();
    // Initialize task ratings map
    for (_i, &id) in index_to_id.iter() {
        if let Some(todo) = with_rid.get(&id) {
            asap.task_ratings.insert(todo.todo.clone(), 0.0);
        }
    }
    // Add comparisons
    for &(i, j) in &comparisons {
        if id_to_index.contains_key(&i) && id_to_index.contains_key(&j) {
            if let (Some(todo_i), Some(todo_j)) = (with_rid.get(&i), with_rid.get(&j)) {
                asap.add_comparison(&todo_i.todo, &todo_j.todo, 0); // Winner is task_a (0)
            }
        }
    }
    // Get ratings
    let ratings = asap.ratings();
    let (pair, prob, ms_curr, vs_curr) = (
        (0, 1), // Default pair to compare
        Vec::<Vec<f64>>::new(), // Empty probability vector
        ratings.iter().map(|(_, score)| *score).collect::<Vec<f64>>(),
        vec![asap.variance; ratings.len()] // Use the same variance for all tasks
    );
    {
        let id_to_index = id_to_index.clone();
        let ms_curr = ms_curr.clone();
        thread::spawn(move || {
            crate::plot_ratings::plot_ratings(
                "ratings.log",
                "ratings_graph",
                &ms_curr,
                &id_to_index,
                &prob,
            )
            .unwrap();
        });
    }
    {
        let index_to_id = index_to_id.clone();
        let ms_curr = ms_curr.clone();
        let vs_curr = vs_curr.clone();
        let with_rid = with_rid.clone();
        thread::spawn(move || {
            let items: Vec<_> = ms_curr
                .iter()
                .zip(vs_curr.iter())
                .enumerate()
                .filter_map(|(i, (&m, &v))| {
                    index_to_id
                        .get(&i)
                        .and_then(|&id| with_rid.get(&id).map(|t| (t.todo.clone(), m, v)))
                })
                .collect();
            plot_ci(items, "ratings_ci.html").unwrap();
        });
    }
    // assign an id / add [[rid::]] to a random todo in without_rid
    if !without_rid.is_empty() && (pair.0 == n - 1 || pair.1 == n - 1) {
        let ix = n - 1;
        let rid = with_rid.iter().map(|(id, _)| id).max().unwrap_or(&0usize) + 1;
        let mut rng = rand::thread_rng();
        let idx = rng.gen_range(0..without_rid.len());
        let todo = without_rid.swap_remove(idx);
        let new_line = if let Some(pos) = EMOJIS.iter().filter_map(|e| todo.todo.find(e)).min() {
            format!(
                "{} [[rid::{}]] {}",
                &todo.todo[..pos],
                rid,
                &todo.todo[pos..]
            )
        } else {
            format!("{} [[rid::{}]]", todo.todo, rid)
        };
        with_rid.insert(rid, todo.clone());
        index_to_id.insert(ix, rid);
        id_to_index.insert(rid, ix);
        replace_line_in_file(&todo.file, todo.line_num, &new_line)?;
    }
    let pair = pair.map(|i| index_to_id.get(&i).unwrap());
    pair.for_each(|id| {
        let t = with_rid.get(id).unwrap();
        println!("{} ({}:{})", t.todo, t.file, t.line_num);
    });
    print!("Enter 1 or 2: ");
    io::stdout().flush()?;
    let c = console::Term::stdout().read_char()?;
    println!();
    let mut file = if let Ok(file) = File::options().append(true).open("ratings.log") {
        file
    } else {
        File::create("ratings.log")?
    };
    writeln!(
        file,
        "{},{}",
        if c == '1' { pair.0 } else { pair.1 },
        if c == '1' { pair.1 } else { pair.0 }
    )?;
    Ok(())
}
#[derive(Clone)]
struct Todo {
    file: String,
    line_num: usize,
    todo: String,
}
fn get_todos() -> io::Result<(HashMap<usize, Todo>, Vec<Todo>)> {
    let command_output = Command::new("rg")
        .args(&[r"^\s*- \[ \]", ".", "-n"])
        .output()?;
    let output = String::from_utf8_lossy(&command_output.stdout);
    if !command_output.status.success() {
        println!("Error running rg, is it installed?");
    }
    let mut with_rid = HashMap::new();
    let mut without_rid = Vec::new();
    for line in output.lines() {
        let parts: Vec<&str> = line.splitn(3, ':').collect();
        if parts.len() == 3 {
            let line = parts[2];
            let todo = Todo {
                file: parts[0].to_string(),
                line_num: parts[1].parse().unwrap(),
                todo: line.to_string(),
            };
            if let Some(start) = line.find("[[rid::") {
                if let Some(end) = line[start..].find("]]") {
                    if let Ok(rid) = line[start + 7..start + end].parse() {
                        with_rid.insert(rid, todo);
                    } else {
                        println!("Invalid rid: {}", &line[start + 7..start + end]);
                    }
                } else {
                    println!("Invalid rid: {}", &line[start..]);
                }
            } else {
                without_rid.push(todo);
            }
        }
    }
    Ok((with_rid, without_rid))
}
fn replace_line_in_file(file: &str, line_num: usize, new_content: &str) -> io::Result<()> {
    let content = std::fs::read_to_string(file)?;
    let mut lines: Vec<String> = content.lines().map(String::from).collect();
    if line_num > lines.len() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!("line {} is out of bounds", line_num),
        ));
    }
    lines[line_num - 1] = new_content.to_string();
    std::fs::write(file, lines.join("\n"))?;
    Ok(())
}
</file>

<file path="web/src/utils/apiClient.ts">
import axios from 'axios';
import type { Task, Comparison } from './markdownUtils';
// Define API base URL based on environment
// For monolithic deployment, API is at /api path with no full URL needed
const API_BASE_URL = 
  // In dev mode (localhost) use the local API with specific port
  window.location.hostname === 'localhost' 
    ? 'http://localhost:3000/api' 
    // In production, API is at /api path on the same origin
    : '/api';
console.log('Using API URL:', API_BASE_URL);
// API client instance
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
// API logging utility
const logApiOperation = (operation: string, data?: any, error?: any) => {
  const timestamp = new Date().toISOString();
  if (error) {
    console.error(`[${timestamp}] API ${operation} failed:`, error);
    if (error.response) {
      console.error(`[${timestamp}] Response:`, {
        status: error.response.status,
        data: error.response.data
      });
    }
  } else {
    console.log(`[${timestamp}] API ${operation} successful`, data || '');
  }
};
// Interface for ranked tasks from the backend
export interface RankedTask extends Task {
  score: number;
  rank: number;
}
// Interface for task response from updated API
interface TaskResponse {
  content: string;
  completed: boolean;
}
// API endpoints for comparisons
export const comparisonsApi = {
  // Get all comparisons
  getAllComparisons: async (): Promise<Comparison[]> => {
    try {
      const response = await apiClient.get('/comparisons');
      const comparisons = response.data.comparisons.map((comp: any) => ({
        id: comp.id || generateId(),
        taskA: { id: `task-${comp.task_a_id}`, content: '', completed: false, line: 0 },
        taskB: { id: `task-${comp.task_b_id}`, content: '', completed: false, line: 0 },
        winner: { id: `task-${comp.winner_id}`, content: '', completed: false, line: 0 },
        timestamp: new Date(comp.timestamp)
      }));
      logApiOperation('getAllComparisons', { count: comparisons.length });
      return comparisons;
    } catch (error) {
      logApiOperation('getAllComparisons', undefined, error);
      throw error;
    }
  },
  // Add a new comparison using task content
  addComparison: async (comparison: Omit<Comparison, 'id' | 'timestamp'>): Promise<Comparison> => {
    try {
      const payload = {
        task_a_content: comparison.taskA.content,
        task_b_content: comparison.taskB.content,
        winner_content: comparison.winner.content
      };
      logApiOperation('addComparison - request', payload);
      // Validate that we have content for all tasks
      if (!comparison.taskA.content || !comparison.taskB.content || !comparison.winner.content) {
        throw new Error('Task content cannot be empty');
      }
      // Make sure winner is one of the tasks being compared
      if (comparison.winner.content !== comparison.taskA.content && 
          comparison.winner.content !== comparison.taskB.content) {
        throw new Error(`Winner content must match either task A or task B`);
      }
      // Send the comparison to the API
      try {
        const response = await apiClient.post('/comparisons', payload);
        logApiOperation('addComparison - response', response.data);
      } catch (err: any) {
        logApiOperation('addComparison', payload, err);
        throw err;
      }
      return {
        id: generateId(),
        taskA: comparison.taskA,
        taskB: comparison.taskB,
        winner: comparison.winner,
        timestamp: new Date()
      };
    } catch (error) {
      logApiOperation('addComparison - error', undefined, error);
      throw error;
    }
  },
};
// API endpoint for rankings
export const rankingsApi = {
  // Get task rankings
  getRankings: async (): Promise<RankedTask[]> => {
    logApiOperation('getRankings - starting');
    try {
      const response = await apiClient.get('/rankings');
      logApiOperation('getRankings - received', response.data);
      if (!response.data.rankings || !Array.isArray(response.data.rankings)) {
        logApiOperation('getRankings - invalid format', response.data);
        return [];
      }
      // Process content-based rankings
      const rankings = response.data.rankings.map((task: any, index: number) => {
        return {
          id: `task-${index + 1}`, // Generate a synthetic ID for frontend use
          content: task.content || '',
          completed: false, // We don't track this in the API anymore
          line: 0, // We don't track this in the API anymore
          score: typeof task.score === 'number' ? task.score : 0,
          rank: typeof task.rank === 'number' ? task.rank : 0
        };
      });
      logApiOperation('getRankings - processed', { count: rankings.length });
      return rankings;
    } catch (error) {
      logApiOperation('getRankings', undefined, error);
      throw error;
    }
  },
};
// Health check response type
interface HealthCheckResponse {
  status: string;
  db_connected: boolean;
  memory_mode: boolean;
}
// Health check endpoint
export const healthCheck = async (): Promise<boolean> => {
  try {
    const response = await apiClient.get('/health');
    logApiOperation('healthCheck - received', response.data);
    // Check if it's the new response format with db_connected
    if (response.data && typeof response.data === 'object') {
      const healthData = response.data as HealthCheckResponse;
      // If we get a specific memory_mode flag, check if we're using a real database connection
      if ('db_connected' in healthData) {
        return healthData.db_connected === true && healthData.memory_mode === false;
      }
    }
    // Fallback for old response format
    return response.status === 200;
  } catch (error) {
    console.error('API health check failed:', error);
    logApiOperation('healthCheck - failed', undefined, error);
    return false;
  }
};
// Helper function to generate a unique ID
const generateId = (): string => {
  return Math.random().toString(36).substring(2, 15) + 
    Math.random().toString(36).substring(2, 15);
};
// Tasks API for managing tasks directly
export const tasksApi = {
  // Get all tasks
  getAllTasks: async (): Promise<string[]> => {
    logApiOperation('getAllTasks - starting');
    try {
      const response = await apiClient.get('/tasks');
      logApiOperation('getAllTasks - received', response.data);
      // The updated API now returns an array of task objects with content and completed properties
      if (Array.isArray(response.data)) {
        const tasks = response.data.map((task: TaskResponse) => task.content);
        return tasks;
      }
      // Fallback for backward compatibility
      return response.data.tasks || [];
    } catch (error) {
      logApiOperation('getAllTasks', undefined, error);
      throw error;
    }
  },
  // Delete a task by content
  deleteTask: async (content: string): Promise<boolean> => {
    logApiOperation('deleteTask - starting', { content });
    try {
      const response = await apiClient.delete('/tasks', { 
        data: { content } 
      });
      logApiOperation('deleteTask - received', response.data);
      return true;
    } catch (error) {
      logApiOperation('deleteTask', { content }, error);
      throw error;
    }
  },
  // Register a new task
  registerTask: async (content: string): Promise<boolean> => {
    logApiOperation('registerTask - starting', { content });
    try {
      // To register a task, we create a dummy comparison where taskA and taskB are both the new task
      // and the winner is also the new task
      const payload = {
        task_a_content: content,
        task_b_content: content,
        winner_content: content
      };
      const response = await apiClient.post('/comparisons', payload);
      logApiOperation('registerTask - received', response.data);
      return true;
    } catch (error) {
      logApiOperation('registerTask', { content }, error);
      throw error;
    }
  }
};
</file>

<file path="web/package.json">
{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@codemirror/lang-markdown": "^6.3.2",
    "@headlessui/react": "^1.7.18",
    "@uiw/react-codemirror": "^4.23.12",
    "axios": "^1.6.7",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.16",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.33",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.3.3",
    "vite": "^5.0.12"
  },
  "main": "index.js",
  "license": "MIT"
}
</file>

<file path="web/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noImplicitAny": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="web/vite.config.d.ts">
declare const _default: import("vite").UserConfigFnObject;
export default _default;
</file>

<file path="web/vite.config.ts">
import { defineConfig } from 'vite'; import react from '@vitejs/plugin-react'; export default defineConfig({ plugins: [react()] });
</file>

<file path=".gitignore">
# Rust build artifacts
/target/
**/*.rs.bk

# Executables and logs
*.exe
*.log
*.out
*.pyc
*.pyo
*.pyd
*.so
*.dylib
*.dll

# IDE and editor files
/.idea/
*.swp
*.swo
*.swn
*.bak
*.tmp
*.vscode/
.DS_Store
Thumbs.db

# Cargo specific
Cargo.lock

# By default, don't ignore Cargo.lock for libraries, but do for binaries
# Uncomment the next line if this is a binary project
# Cargo.lock

# Misc
*.old
*.orig
*.rej

# Ripgrep
.rg.cache

# Project specific
tasks.md
# Local Netlify folder
.netlify

# Database
.env
.env.local
.env.development
.env.production
</file>

<file path="Cargo.toml">
[package]
name = "sorter"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8.5"
libm = "0.2.15"
tempfile = "3.2"
console = "0.15.8"
either = "1.13.0"
tuple-map = "0.4.0"
# Web service dependencies
axum = "0.6.20"
tokio = { version = "1.32.0", features = ["full"] }
tower = "0.4.13"
tower-http = { version = "0.4.4", features = ["cors"] }
static-files = "0.2.3"
serde = { version = "1.0.188", features = ["derive"] }
serde_json = "1.0.107"
tracing = "0.1.37"
tracing-subscriber = { version = "0.3.17", features = ["env-filter"] }
chrono = { version = "0.4.31", features = ["serde"] }
# Database dependencies
sqlx = { version = "0.6.3", features = ["runtime-tokio-native-tls", "postgres", "chrono", "json", "uuid", "time", "offline"] }
dotenv = "0.15.0"
uuid = { version = "1.4.1", features = ["v4", "serde"] }

[profile.dev]
opt-level = 3
debug = 1
debug-assertions = false
overflow-checks = false
</file>

<file path="README.md">
# Todo Sorter with PostgreSQL

## Database Setup

This project uses PostgreSQL for data persistence. Here's how to set it up:

### Local Development

1. Install PostgreSQL on your machine
2. Create a new database:
   ```bash
   createdb todo_sorter
   ```
3. Configure your database connection in the `.env` file:
   ```
   DATABASE_URL=postgres://postgres:password@localhost:5432/todo_sorter
   ```

### Railway Deployment

1. Create a new project in Railway
2. Add a PostgreSQL database to your project
3. Railway will automatically configure the `DATABASE_URL` environment variable
4. Make sure the following environment variables are set in Railway:
   ```
   PORT=3000
   STATIC_DIR=static
   ```
5. Deploy your application using the Railway CLI or GitHub integration

## Running the Application

To run the application in development mode:

```bash
cargo run api  # Start the backend API server
cd web && yarn dev  # Start the frontend development server
```

For production:

```bash
cargo build --release
cd web && yarn build
cp -r web/dist static
STATIC_DIR=static ./target/release/sorter api
```

## API Endpoints

- `GET /api/health` - Health check
- `GET /api/tasks` - Get all tasks
- `DELETE /api/tasks` - Delete a task
- `GET /api/comparisons` - Get all comparisons
- `POST /api/comparisons` - Add a new comparison
- `GET /api/rankings` - Get task rankings

## Technologies Used

- Backend: Rust with Axum framework and SQLx for database access
- Database: PostgreSQL
- Frontend: React with TypeScript and Tailwind CSS
- Deployment: Railway
</file>

<file path="rust-toolchain.toml">
[toolchain]
channel = "1.82.0"
components = ["rustfmt", "clippy"]
</file>

<file path="sqlx-data.json">
{"db":"PostgreSQL","queries":[]}
</file>

<file path="vite.config.ts">
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'
// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  // Load env file based on `mode` in the current directory.
  // Set the third parameter to '' to load all env regardless of the `VITE_` prefix.
  const env = loadEnv(mode, process.cwd(), '')
  return {
    plugins: [
      react(),
    ],
    resolve: {
      alias: {
        // Add any aliases if needed
      },
    },
    build: {
      // Configure build options for production
      outDir: 'dist',
      minify: 'esbuild',
      chunkSizeWarningLimit: 1000,
    },
    define: {
      // Pass Railway environment variables to the frontend
      'process.env.VITE_API_URL': JSON.stringify(env.VITE_API_URL || 'https://todo-sorter-api-production.up.railway.app'),
    },
  }
})
</file>

<file path="package.json">
{
  "name": "todo-sorter",
  "version": "1.0.0",
  "description": "A todo task sorter application",
  "scripts": {
    "start": "cargo run --bin sorter -- api",
    "dev": "cargo watch -x 'run --bin sorter -- api'",
    "build": "cd web && yarn install && yarn build && cd .."
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "private": true
}
</file>

<file path="Procfile">
web: ./start.sh
</file>

<file path="src/db.rs">
use sqlx::{postgres::PgPoolOptions, PgPool, Error as SqlxError, postgres::PgRow, Row};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;
use std::sync::Arc;
use std::collections::HashMap;
// Task model - simplified version for better compatibility
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    pub id: String,
    pub content: String,
    pub completed: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
// Comparison model - simplified version for better compatibility
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comparison {
    pub id: String,
    pub task_a_id: String,
    pub task_b_id: String,
    pub winner_id: String,
    pub timestamp: DateTime<Utc>,
}
// Response with just task content for backward compatibility
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskContent {
    pub content: String,
    pub completed: bool,
}
// Database connection pool
pub struct Database {
    pub pool: Option<PgPool>,
    pub memory_mode: bool,
}
impl Database {
    // Create a memory-only database instance
    pub fn memory_only() -> Arc<Self> {
        Arc::new(Self {
            pool: None,
            memory_mode: true,
        })
    }
    // Initialize database connection
    pub async fn connect() -> Result<Arc<Self>, SqlxError> {
        // Load from environment variables (.env file in development)
        dotenv::dotenv().ok();
        // Try first using explicit PostgreSQL variables which are optimal for Railway
        let try_connect_with_pg_vars = async {
            let have_pg_vars = std::env::var("PGHOST").is_ok() && 
                              std::env::var("PGPORT").is_ok() && 
                              std::env::var("PGUSER").is_ok() && 
                              std::env::var("PGPASSWORD").is_ok() && 
                              std::env::var("PGDATABASE").is_ok();
            if have_pg_vars {
                let pghost = std::env::var("PGHOST").unwrap();
                let pgport = std::env::var("PGPORT").unwrap();
                let pguser = std::env::var("PGUSER").unwrap();
                let pgpassword = std::env::var("PGPASSWORD").unwrap();
                let pgdatabase = std::env::var("PGDATABASE").unwrap();
                let is_railway_internal = pghost.contains(".railway.internal");
                if is_railway_internal {
                    tracing::info!("Using Railway internal network with explicit PG* variables");
                    tracing::info!("PGHOST={}, PGPORT={}, PGDATABASE={}", pghost, pgport, pgdatabase);
                    // Construct an optimized connection string for Railway internal network
                    let connection_string = format!(
                        "postgres://{}:{}@{}:{}/{}?application_name=todo-sorter&connect_timeout=10",
                        pguser, pgpassword, pghost, pgport, pgdatabase
                    );
                    // Attempt to connect using explicit PG* variables
                    match Self::connect_with_retry(&connection_string, 5).await {
                        Ok(pool) => {
                            tracing::info!("Successfully connected with Railway internal network PG* variables");
                            return Some(Arc::new(Self { pool: Some(pool), memory_mode: false }));
                        },
                        Err(e) => {
                            tracing::warn!("Failed to connect with explicit PG* variables: {}", e);
                            tracing::warn!("Will fallback to DATABASE_URL if available");
                            // Fallback to DATABASE_URL
                        }
                    }
                }
            }
            None
        };
        // Try connecting with explicit PG variables first
        if let Some(db) = try_connect_with_pg_vars.await {
            return Ok(db);
        }
        // Fallback to DATABASE_URL
        match std::env::var("DATABASE_URL") {
            Ok(database_url) => {
                // Only log the host part, not credentials
                let host_part = database_url.split('@').nth(1).unwrap_or("(hidden)");
                tracing::info!("Attempting to connect to database at: {}", host_part);
                if let Some(db_url_parts) = database_url.split('@').nth(1) {
                    if db_url_parts.contains("railway.internal") {
                        tracing::info!("Detected Railway internal network address - using optimized connection settings");
                    }
                }
                // Log information about the current environment
                if let Ok(env) = std::env::var("RAILWAY_ENVIRONMENT") {
                    tracing::info!("Running in Railway environment: {}", env);
                }
                // Connect to the database with retries
                match Self::connect_with_retry(&database_url, 5).await {
                    Ok(pool) => {
                        tracing::info!("Successfully connected to PostgreSQL database");
                        return Ok(Arc::new(Self { pool: Some(pool), memory_mode: false }));
                    },
                    Err(err) => {
                        tracing::error!("All database connection attempts failed! Last error: {}", err);
                        tracing::warn!("Running in memory-only mode. Data will not be persisted!");
                        // Log additional helpful info for connection failures
                        if let Ok(pghost) = std::env::var("PGHOST") {
                            tracing::info!("PGHOST environment variable is set to: {}", pghost);
                        }
                        if let Ok(port) = std::env::var("PGPORT") {
                            tracing::info!("PGPORT environment variable is set to: {}", port);
                        }
                        Ok(Arc::new(Self { pool: None, memory_mode: true }))
                    }
                }
            },
            Err(err) => {
                // If DATABASE_URL is not set, operate in memory-only mode
                tracing::warn!("DATABASE_URL not set or invalid ({}). Running in memory-only mode. Data will not be persisted!", err);
                Ok(Arc::new(Self { pool: None, memory_mode: true }))
            }
        }
    }
    // Helper method for connection with retry logic
    async fn connect_with_retry(database_url: &str, max_retries: u32) -> Result<PgPool, SqlxError> {
        let mut last_error = None;
        for attempt in 1..=max_retries {
            tracing::info!("Database connection attempt {} of {}", attempt, max_retries);
            // Connect to the database with increased timeout
            let pool_result = PgPoolOptions::new()
                .max_connections(5)
                .acquire_timeout(std::time::Duration::from_secs(60)) // Increased timeout
                .connect(database_url)
                .await;
            match pool_result {
                Ok(pool) => {
                    // Test the connection with a simple query
                    match sqlx::query("SELECT 1").execute(&pool).await {
                        Ok(_) => {
                            // Create tables if they don't exist
                            match Self::initialize_tables(&pool).await {
                                Ok(_) => {
                                    tracing::info!("Successfully connected to PostgreSQL database and created tables");
                                    return Ok(pool);
                                },
                                Err(err) => {
                                    tracing::error!("Failed to initialize database tables: {}", err);
                                    last_error = Some(err);
                                    // Continue to next attempt
                                }
                            }
                        },
                        Err(err) => {
                            tracing::error!("Database connection test failed: {}", err);
                            last_error = Some(err);
                            // Continue to next attempt
                        }
                    }
                },
                Err(err) => {
                    tracing::error!("Database connection attempt {} failed: {}", attempt, err);
                    last_error = Some(err);
                    // Continue to next attempt
                }
            }
            // Wait before retrying with exponential backoff
            if attempt < max_retries {
                let delay = std::time::Duration::from_secs(2 * attempt as u64);
                tracing::info!("Waiting {:?} before next connection attempt", delay);
                tokio::time::sleep(delay).await;
            }
        }
        // All attempts failed
        Err(last_error.unwrap_or_else(|| SqlxError::PoolClosed))
    }
    // Create database tables if they don't exist
    async fn initialize_tables(pool: &PgPool) -> Result<(), SqlxError> {
        // Create tasks table
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS tasks (
                id UUID PRIMARY KEY,
                content TEXT NOT NULL,
                completed BOOLEAN NOT NULL DEFAULT FALSE,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            );
        "#).execute(pool).await?;
        // Create comparisons table
        sqlx::query(r#"
            CREATE TABLE IF NOT EXISTS comparisons (
                id UUID PRIMARY KEY,
                task_a_id UUID NOT NULL REFERENCES tasks(id),
                task_b_id UUID NOT NULL REFERENCES tasks(id),
                winner_id UUID NOT NULL REFERENCES tasks(id),
                timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
            );
        "#).execute(pool).await?;
        Ok(())
    }
    // Task operations
    pub async fn get_tasks(&self) -> Result<Vec<Task>, SqlxError> {
        if self.memory_mode {
            // Return empty list in memory mode
            return Ok(Vec::new());
        }
        let pool = self.pool.as_ref().unwrap();
        let rows = sqlx::query(
            "SELECT id::text, content, completed, created_at, updated_at FROM tasks ORDER BY created_at DESC"
        )
        .fetch_all(pool)
        .await?;
        Ok(rows.into_iter().map(|row: PgRow| Task {
            id: row.get("id"),
            content: row.get("content"),
            completed: row.get("completed"),
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
        }).collect())
    }
    pub async fn get_task_by_content(&self, content: &str) -> Result<Option<Task>, SqlxError> {
        if self.memory_mode {
            // Return None in memory mode
            return Ok(None);
        }
        let pool = self.pool.as_ref().unwrap();
        let row = sqlx::query(
            "SELECT id::text, content, completed, created_at, updated_at FROM tasks WHERE content = $1"
        )
        .bind(content)
        .fetch_optional(pool)
        .await?;
        Ok(row.map(|row: PgRow| Task {
            id: row.get("id"),
            content: row.get("content"),
            completed: row.get("completed"),
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
        }))
    }
    pub async fn create_task(&self, content: String) -> Result<Task, SqlxError> {
        // In memory mode, create a dummy task
        if self.memory_mode {
            let id = Uuid::new_v4();
            let now = Utc::now();
            return Ok(Task {
                id: id.to_string(),
                content,
                completed: false,
                created_at: now,
                updated_at: now,
            });
        }
        // Check if task with this content already exists
        if let Some(task) = self.get_task_by_content(&content).await? {
            return Ok(task);
        }
        let pool = self.pool.as_ref().unwrap();
        let id = Uuid::new_v4();
        let now = Utc::now();
        let row = sqlx::query(
            "INSERT INTO tasks (id, content, completed, created_at, updated_at) 
             VALUES ($1, $2, $3, $4, $5) 
             RETURNING id::text, content, completed, created_at, updated_at"
        )
        .bind(id)
        .bind(&content)
        .bind(false)
        .bind(now)
        .bind(now)
        .fetch_one(pool)
        .await?;
        Ok(Task {
            id: row.get("id"),
            content: row.get("content"),
            completed: row.get("completed"),
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
        })
    }
    pub async fn delete_task(&self, content: &str) -> Result<bool, SqlxError> {
        // In memory mode, pretend to succeed
        if self.memory_mode {
            return Ok(true);
        }
        let pool = self.pool.as_ref().unwrap();
        // Get the task first to find its ID
        let task = match self.get_task_by_content(content).await? {
            Some(t) => t,
            None => return Ok(false),
        };
        let uuid_id = Uuid::parse_str(&task.id).unwrap();
        // Delete related comparisons first (to satisfy foreign key constraints)
        sqlx::query(
            "DELETE FROM comparisons 
             WHERE task_a_id = $1 OR task_b_id = $1 OR winner_id = $1"
        )
        .bind(uuid_id)
        .execute(pool)
        .await?;
        // Now delete the task
        let result = sqlx::query(
            "DELETE FROM tasks WHERE id = $1"
        )
        .bind(uuid_id)
        .execute(pool)
        .await?;
        Ok(result.rows_affected() > 0)
    }
    // Comparison operations
    pub async fn get_comparisons(&self) -> Result<Vec<Comparison>, SqlxError> {
        // In memory mode, return empty list
        if self.memory_mode {
            return Ok(Vec::new());
        }
        let pool = self.pool.as_ref().unwrap();
        let rows = sqlx::query(
            "SELECT id::text, task_a_id::text, task_b_id::text, winner_id::text, timestamp FROM comparisons ORDER BY timestamp DESC"
        )
        .fetch_all(pool)
        .await?;
        Ok(rows.into_iter().map(|row: PgRow| Comparison {
            id: row.get("id"),
            task_a_id: row.get("task_a_id"),
            task_b_id: row.get("task_b_id"),
            winner_id: row.get("winner_id"),
            timestamp: row.get("timestamp"),
        }).collect())
    }
    pub async fn add_comparison(
        &self, 
        task_a_content: &str, 
        task_b_content: &str, 
        winner_content: &str
    ) -> Result<Comparison, SqlxError> {
        // In memory mode, create dummy comparison
        if self.memory_mode {
            let id = Uuid::new_v4();
            let task_a_id = Uuid::new_v4();
            let task_b_id = Uuid::new_v4();
            let winner_id = if winner_content == task_a_content {
                task_a_id
            } else {
                task_b_id
            };
            return Ok(Comparison {
                id: id.to_string(),
                task_a_id: task_a_id.to_string(),
                task_b_id: task_b_id.to_string(),
                winner_id: winner_id.to_string(),
                timestamp: Utc::now(),
            });
        }
        let pool = self.pool.as_ref().unwrap();
        // Get or create tasks first
        let task_a = self.create_task(task_a_content.to_string()).await?;
        let task_b = self.create_task(task_b_content.to_string()).await?;
        let winner_id = if winner_content == task_a_content {
            Uuid::parse_str(&task_a.id).unwrap()
        } else if winner_content == task_b_content {
            Uuid::parse_str(&task_b.id).unwrap()
        } else {
            return Err(SqlxError::Protocol("Winner must be one of the compared tasks".into()));
        };
        let task_a_id = Uuid::parse_str(&task_a.id).unwrap();
        let task_b_id = Uuid::parse_str(&task_b.id).unwrap();
        let id = Uuid::new_v4();
        let row = sqlx::query(
            "INSERT INTO comparisons (id, task_a_id, task_b_id, winner_id, timestamp) 
             VALUES ($1, $2, $3, $4, NOW()) 
             RETURNING id::text, task_a_id::text, task_b_id::text, winner_id::text, timestamp"
        )
        .bind(id)
        .bind(task_a_id)
        .bind(task_b_id)
        .bind(winner_id)
        .fetch_one(pool)
        .await?;
        Ok(Comparison {
            id: row.get("id"),
            task_a_id: row.get("task_a_id"),
            task_b_id: row.get("task_b_id"),
            winner_id: row.get("winner_id"),
            timestamp: row.get("timestamp"),
        })
    }
    pub async fn get_task_content_by_id(&self, id: &str) -> Result<Option<String>, SqlxError> {
        // In memory mode, return dummy content
        if self.memory_mode {
            return Ok(Some(format!("Task {}", id)));
        }
        let pool = self.pool.as_ref().unwrap();
        let uuid_id = Uuid::parse_str(id).unwrap();
        let row = sqlx::query("SELECT content FROM tasks WHERE id = $1")
            .bind(uuid_id)
            .fetch_optional(pool)
            .await?;
        Ok(row.map(|row: PgRow| row.get("content")))
    }
    // Helper method to diagnose connection timeouts
    pub async fn test_connection(&self) -> Result<HashMap<String, String>, SqlxError> {
        let mut results = HashMap::new();
        if self.memory_mode {
            results.insert("mode".to_string(), "memory_only".to_string());
            results.insert("status".to_string(), "no_database_connection".to_string());
            return Ok(results);
        }
        match &self.pool {
            Some(pool) => {
                // Get the current time for timing measurements
                let start = std::time::Instant::now();
                // Try a simple query first
                match sqlx::query("SELECT 1").execute(pool).await {
                    Ok(_) => {
                        let elapsed = start.elapsed();
                        results.insert("query_test".to_string(), "success".to_string());
                        results.insert("query_time_ms".to_string(), elapsed.as_millis().to_string());
                    },
                    Err(err) => {
                        results.insert("query_test".to_string(), "error".to_string());
                        results.insert("query_error".to_string(), err.to_string());
                        // Check if it's a timeout error
                        if err.to_string().contains("timeout") {
                            results.insert("error_type".to_string(), "timeout".to_string());
                            // Check DNS resolution if it's a timeout
                            if let Ok(pghost) = std::env::var("PGHOST") {
                                if pghost.contains(".railway.internal") {
                                    // Check DNS resolution with getent
                                    match tokio::process::Command::new("getent")
                                        .args(&["hosts", &pghost])
                                        .output()
                                        .await {
                                        Ok(output) => {
                                            if output.status.success() {
                                                let stdout = String::from_utf8_lossy(&output.stdout);
                                                results.insert("dns_resolution".to_string(), format!("success: {}", stdout.trim()));
                                            } else {
                                                let stderr = String::from_utf8_lossy(&output.stderr);
                                                results.insert("dns_resolution".to_string(), format!("error: {}", stderr.trim()));
                                            }
                                        },
                                        Err(e) => {
                                            results.insert("dns_resolution".to_string(), format!("command_error: {}", e));
                                        }
                                    }
                                }
                            }
                            // Get networking environment
                            if let Ok(env) = std::env::var("RAILWAY_ENVIRONMENT") {
                                results.insert("railway_environment".to_string(), env);
                            }
                            if let Ok(project) = std::env::var("RAILWAY_PROJECT_ID") {
                                results.insert("railway_project_id".to_string(), project);
                            }
                        }
                    }
                }
                // Try a connection stats query
                match sqlx::query("SELECT count(*) FROM pg_stat_activity").fetch_one(pool).await {
                    Ok(row) => {
                        let connections: i64 = row.get(0);
                        results.insert("active_connections".to_string(), connections.to_string());
                    },
                    Err(err) => {
                        results.insert("connection_stats".to_string(), format!("error: {}", err));
                    }
                }
                Ok(results)
            },
            None => {
                results.insert("status".to_string(), "no_pool".to_string());
                Ok(results)
            }
        }
    }
}
pub async fn get_task_contents_from_comparison(
    db: &Database,
    comparison: &Comparison
) -> Result<(String, String, String), SqlxError> {
    let task_a_content = db.get_task_content_by_id(&comparison.task_a_id).await?
        .ok_or_else(|| SqlxError::RowNotFound)?;
    let task_b_content = db.get_task_content_by_id(&comparison.task_b_id).await?
        .ok_or_else(|| SqlxError::RowNotFound)?;
    let winner_content = if comparison.winner_id == comparison.task_a_id {
        task_a_content.clone()
    } else {
        task_b_content.clone()
    };
    Ok((task_a_content, task_b_content, winner_content))
}
</file>

<file path="src/web_service.rs">
use axum::{
    http::{header, StatusCode, Uri},
    response::{IntoResponse, Response},
    routing::{get, delete},
    Json, Router, Extension,
};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::sync::{Arc};
use tower_http::cors::{Any, CorsLayer};
use crate::asap_cpu::ASAP;
use crate::db::{Database, TaskContent};
// Type for storing our application state
pub struct AppState {
    db: Arc<Database>,
}
// Task info using content as the primary identifier
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct TaskInfo {
    content: String,
    completed: bool,
}
// For backward compatibility in responses - using content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContentComparison {
    task_a_content: String,
    task_b_content: String,
    winner_content: String,
    timestamp: String,
}
// For backward compatibility in responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LegacyComparison {
    task_a_id: usize,
    task_b_id: usize,
    winner_id: usize,
    timestamp: String,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct RankedTask {
    content: String,
    score: f64,
    rank: usize,
}
// Requests and responses
#[derive(Debug, Deserialize)]
pub struct AddComparisonRequest {
    task_a_content: String,
    task_b_content: String,
    winner_content: String,
}
// Request for deleting a task
#[derive(Debug, Deserialize)]
pub struct DeleteTaskRequest {
    content: String,
}
#[derive(Debug, Serialize)]
pub struct ComparisonsResponse {
    comparisons: Vec<LegacyComparison>,
}
#[derive(Debug, Serialize)]
pub struct RankingsResponse {
    rankings: Vec<RankedTask>,
}
// Database health check response type
#[derive(Debug, Serialize)]
pub struct HealthCheckResponse {
    status: String,
    db_connected: bool,
    memory_mode: bool,
    diagnostics: HashMap<String, String>,
}
// Simple function to serve static files
async fn serve_static_file(uri: Uri) -> impl IntoResponse {
    let mut path = uri.path().trim_start_matches('/').to_string();
    // If path is empty, serve index.html
    if path.is_empty() {
        path = "index.html".to_string();
    }
    // Resolve path to the static directory
    let static_dir = std::env::var("STATIC_DIR").unwrap_or_else(|_| "static".to_string());
    let file_path = format!("{}/{}", static_dir, path);
    // Try to read the file
    match tokio::fs::read(&file_path).await {
        Ok(contents) => {
            // Set the appropriate content type based on the file extension
            let content_type = match file_path.split('.').last() {
                Some("html") => "text/html",
                Some("css") => "text/css",
                Some("js") => "application/javascript",
                Some("json") => "application/json",
                Some("png") => "image/png",
                Some("jpg") | Some("jpeg") => "image/jpeg",
                Some("svg") => "image/svg+xml",
                Some("ico") => "image/x-icon",
                _ => "application/octet-stream",
            };
            // Create a response with the file contents and content type
            Response::builder()
                .status(StatusCode::OK)
                .header(header::CONTENT_TYPE, content_type)
                .body(axum::body::Body::from(contents))
                .unwrap()
        },
        Err(_) => {
            // Return a 404 Not Found response
            Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body(axum::body::Body::from("File not found"))
                .unwrap()
        }
    }
}
pub async fn run_web_service() {
    // Initialize tracing for better logging
    tracing_subscriber::fmt::init();
    // Connect to the database
    let db = match Database::connect().await {
        Ok(db) => {
            tracing::info!("Database connection established");
            db
        },
        Err(err) => {
            tracing::error!("Failed to connect to the database: {}", err);
            tracing::warn!("Starting with in-memory mode - data will not be persisted");
            // Create a memory-only database as fallback
            Database::memory_only()
        }
    };
    // Create the application state
    let shared_state = Arc::new(AppState { db });
    // Define CORS policy to allow requests from frontend
    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);
    // Get the static files directory from the environment or use the default
    let static_dir = std::env::var("STATIC_DIR").unwrap_or_else(|_| "static".to_string());
    tracing::info!("Serving static files from: {}", static_dir);
    // Create API router with shared state
    let api_routes = Router::new()
        .route("/health", get(health_check))
        .route("/db-diagnostic", get(db_diagnostic))
        .route("/comparisons", get(get_comparisons).post(add_comparison))
        .route("/rankings", get(get_rankings))
        .route("/tasks", get(get_tasks).delete(delete_task))
        .layer(Extension(shared_state))
        .layer(cors);
    // Create our application router
    let app = Router::new()
        .nest("/api", api_routes) // Move all API routes under /api prefix
        .fallback(serve_static_file); // Serve static files for all other routes
    // Run our service
    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let port = port.parse::<u16>().expect("PORT must be a number");
    let addr = std::net::SocketAddr::from(([0, 0, 0, 0], port));
    tracing::info!("Listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
// Health check endpoint
async fn health_check(Extension(state): Extension<Arc<AppState>>) -> impl IntoResponse {
    // Check if we're using memory mode or real database
    let is_memory_mode = state.db.memory_mode;
    let mut is_db_connected = state.db.pool.is_some();
    // Collect diagnostic information
    let mut diagnostics = HashMap::new();
    // Add environment info
    if let Ok(env) = std::env::var("RAILWAY_ENVIRONMENT") {
        diagnostics.insert("railway_environment".to_string(), env);
    }
    if let Ok(project_id) = std::env::var("RAILWAY_PROJECT_ID") {
        diagnostics.insert("railway_project_id".to_string(), project_id);
    }
    // Add database connection info
    if let Ok(host) = std::env::var("PGHOST") {
        diagnostics.insert("pghost".to_string(), host);
    }
    if let Ok(port) = std::env::var("PGPORT") {
        diagnostics.insert("pgport".to_string(), port);
    }
    if let Ok(db) = std::env::var("PGDATABASE") {
        diagnostics.insert("pgdatabase".to_string(), db);
    }
    // Redacted values
    if std::env::var("PGUSER").is_ok() {
        diagnostics.insert("pguser".to_string(), "is_set".to_string());
    }
    if std::env::var("PGPASSWORD").is_ok() {
        diagnostics.insert("pgpassword".to_string(), "is_set".to_string());
    }
    if let Ok(url) = std::env::var("DATABASE_URL") {
        // Only show host portion
        if let Some(host_part) = url.split('@').nth(1) {
            diagnostics.insert("database_url_host".to_string(), host_part.to_string());
        } else {
            diagnostics.insert("database_url".to_string(), "is_set_but_invalid_format".to_string());
        }
    }
    // Add sqlx offline mode info
    if let Ok(offline) = std::env::var("SQLX_OFFLINE") {
        diagnostics.insert("sqlx_offline".to_string(), offline);
    }
    // Attempt a real-time check of the database connection
    if is_db_connected {
        match &state.db.pool {
            Some(pool) => {
                // Test the connection with a simple query
                match sqlx::query("SELECT 1").execute(pool).await {
                    Ok(_) => {
                        tracing::info!("Health check: Database connection verified");
                        is_db_connected = true;
                        diagnostics.insert("db_connection_test".to_string(), "success".to_string());
                    },
                    Err(err) => {
                        tracing::error!("Health check: Database connection failed: {}", err);
                        is_db_connected = false;
                        diagnostics.insert("db_connection_test".to_string(), format!("error: {}", err));
                    }
                }
            },
            None => {
                is_db_connected = false;
                diagnostics.insert("db_connection_test".to_string(), "memory_mode_no_test_needed".to_string());
            }
        }
    } else {
        diagnostics.insert("db_connection_test".to_string(), "memory_mode_no_test_needed".to_string());
    }
    // Perform DNS resolution test for Railway internal network if we're on Railway
    if let Ok(host) = std::env::var("PGHOST") {
        if host.contains(".railway.internal") {
            // Try to execute a test command to resolve the hostname
            match tokio::process::Command::new("getent")
                .args(&["hosts", &host])
                .output()
                .await {
                Ok(output) => {
                    if output.status.success() {
                        let stdout = String::from_utf8_lossy(&output.stdout);
                        diagnostics.insert("dns_resolution".to_string(), format!("success: {}", stdout.trim()));
                    } else {
                        let stderr = String::from_utf8_lossy(&output.stderr);
                        diagnostics.insert("dns_resolution".to_string(), format!("failed: {}", stderr.trim()));
                    }
                },
                Err(err) => {
                    diagnostics.insert("dns_resolution".to_string(), format!("error: {}", err));
                }
            }
        }
    }
    (
        StatusCode::OK,
        Json(HealthCheckResponse {
            status: if is_db_connected { "ok".to_string() } else { "degraded".to_string() },
            db_connected: is_db_connected,
            memory_mode: is_memory_mode,
            diagnostics,
        })
    )
}
// Database diagnostic endpoint
async fn db_diagnostic(Extension(state): Extension<Arc<AppState>>) -> impl IntoResponse {
    let diagnostics = match state.db.test_connection().await {
        Ok(results) => results,
        Err(e) => {
            let mut error_map = std::collections::HashMap::new();
            error_map.insert("error".to_string(), format!("Failed to run diagnostics: {}", e));
            error_map
        }
    };
    (StatusCode::OK, Json(diagnostics))
}
// Get all comparisons
async fn get_comparisons(Extension(state): Extension<Arc<AppState>>) -> impl IntoResponse {
    match state.db.get_comparisons().await {
        Ok(db_comparisons) => {
            // Convert database comparisons to content-based format
            let mut content_comparisons = Vec::new();
            for comparison in db_comparisons {
                // Get task contents from the database
                match crate::db::get_task_contents_from_comparison(&state.db, &comparison).await {
                    Ok((task_a_content, task_b_content, winner_content)) => {
                        content_comparisons.push(ContentComparison {
                            task_a_content,
                            task_b_content,
                            winner_content,
                            timestamp: comparison.timestamp.to_rfc3339(),
                        });
                    },
                    Err(e) => {
                        tracing::error!("Failed to get task contents: {}", e);
                    }
                }
            }
            // Convert content-based comparisons back to ID-based for legacy support
            let legacy_comparisons: Vec<LegacyComparison> = content_comparisons
                .iter()
                .enumerate()
                .map(|(i, comp)| LegacyComparison {
                    task_a_id: i + 1,
                    task_b_id: i + 2,
                    winner_id: if comp.winner_content == comp.task_a_content { i + 1 } else { i + 2 },
                    timestamp: comp.timestamp.clone(),
                })
                .collect();
            (StatusCode::OK, Json(ComparisonsResponse { comparisons: legacy_comparisons }))
        },
        Err(e) => {
            tracing::error!("Failed to get comparisons: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, Json(ComparisonsResponse { comparisons: vec![] }))
        }
    }
}
// Add a new comparison
async fn add_comparison(
    Extension(state): Extension<Arc<AppState>>,
    Json(payload): Json<AddComparisonRequest>,
) -> impl IntoResponse {
    // Validate input
    if payload.task_a_content.trim().is_empty() || payload.task_b_content.trim().is_empty() || payload.winner_content.trim().is_empty() {
        return (StatusCode::BAD_REQUEST, Json(ComparisonsResponse { comparisons: vec![] }));
    }
    // Winner must be one of task A or task B
    if payload.winner_content != payload.task_a_content && payload.winner_content != payload.task_b_content {
        return (StatusCode::BAD_REQUEST, Json(ComparisonsResponse { comparisons: vec![] }));
    }
    match state.db.add_comparison(&payload.task_a_content, &payload.task_b_content, &payload.winner_content).await {
        Ok(_) => (StatusCode::CREATED, Json(ComparisonsResponse { comparisons: vec![] })),
        Err(e) => {
            tracing::error!("Failed to add comparison: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, Json(ComparisonsResponse { comparisons: vec![] }))
        }
    }
}
// Get rankings
async fn get_rankings(Extension(state): Extension<Arc<AppState>>) -> impl IntoResponse {
    // First, get all comparisons from the database
    match state.db.get_comparisons().await {
        Ok(comparisons) => {
            if comparisons.is_empty() {
                return (StatusCode::OK, Json(RankingsResponse { rankings: vec![] }));
            }
            // Extract all tasks that have been compared
            let mut all_tasks = HashSet::new();
            let mut task_contents = HashMap::new();
            // Process all comparisons to extract task contents
            for comparison in &comparisons {
                // Get contents for all tasks in this comparison
                match crate::db::get_task_contents_from_comparison(&state.db, comparison).await {
                    Ok((task_a_content, task_b_content, winner_content)) => {
                        // Store task ID to content mappings
                        task_contents.insert(comparison.task_a_id.clone(), task_a_content.clone());
                        task_contents.insert(comparison.task_b_id.clone(), task_b_content.clone());
                        task_contents.insert(comparison.winner_id.clone(), winner_content.clone());
                        // Create TaskInfo objects
                        all_tasks.insert(TaskInfo {
                            content: task_a_content,
                            completed: false,
                        });
                        all_tasks.insert(TaskInfo {
                            content: task_b_content,
                            completed: false,
                        });
                    },
                    Err(e) => {
                        tracing::error!("Failed to get task contents: {}", e);
                        continue;
                    }
                }
            }
            // Create ASAP ranker from comparisons
            let mut asap = ASAP::new();
            for comparison in &comparisons {
                if let (Some(task_a_content), Some(task_b_content), Some(winner_content)) = (
                    task_contents.get(&comparison.task_a_id),
                    task_contents.get(&comparison.task_b_id),
                    task_contents.get(&comparison.winner_id)
                ) {
                    // Get the winner (0 for task A, 1 for task B)
                    let winner = if winner_content == task_a_content { 0 } else { 1 };
                    // Add the comparison to ASAP
                    asap.add_comparison(task_a_content, task_b_content, winner);
                }
            }
            // Get rankings from ASAP
            let rankings = asap.ratings();
            // Convert to RankedTask format
            let mut ranked_tasks: Vec<RankedTask> = rankings
                .into_iter()
                .map(|(content, score)| RankedTask {
                    content: content.to_string(),
                    score,
                    rank: 0, // Will be set later
                })
                .collect();
            // Sort by score (highest first)
            ranked_tasks.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
            // Assign ranks
            for (i, task) in ranked_tasks.iter_mut().enumerate() {
                task.rank = i + 1;
            }
            (StatusCode::OK, Json(RankingsResponse { rankings: ranked_tasks }))
        },
        Err(e) => {
            tracing::error!("Failed to get comparisons for rankings: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, Json(RankingsResponse { rankings: vec![] }))
        }
    }
}
// Get all tasks
async fn get_tasks(Extension(state): Extension<Arc<AppState>>) -> impl IntoResponse {
    match state.db.get_tasks().await {
        Ok(tasks) => {
            // Extract just the content strings for backward compatibility
            let task_contents: Vec<TaskContent> = tasks.into_iter()
                .map(|task| TaskContent { 
                    content: task.content, 
                    completed: task.completed
                })
                .collect();
            (StatusCode::OK, Json(task_contents))
        },
        Err(e) => {
            tracing::error!("Failed to get tasks: {}", e);
            (StatusCode::INTERNAL_SERVER_ERROR, Json::<Vec<TaskContent>>(vec![]))
        }
    }
}
// Delete a task
async fn delete_task(
    Extension(state): Extension<Arc<AppState>>,
    Json(payload): Json<DeleteTaskRequest>,
) -> impl IntoResponse {
    match state.db.delete_task(&payload.content).await {
        Ok(true) => StatusCode::OK,
        Ok(false) => StatusCode::NOT_FOUND,
        Err(e) => {
            tracing::error!("Failed to delete task: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        }
    }
}
</file>

<file path="railway.toml">
[build]
builder = "nixpacks"

[deploy]
startCommand = "./start.sh"
healthcheckPath = "/api/health"
healthcheckTimeout = 100
restartPolicyType = "on_failure"
autostart = true

# Railway automatically injects DATABASE_URL environment variable
# when you provision a PostgreSQL database

[services.web]
healthcheck = "/api/health"
port = 3000

# Environment variables
[variables]
PORT = "3000"
STATIC_DIR = "/app/static"
SQLX_OFFLINE = "false"
</file>

<file path="start.sh">
#!/bin/bash
set -e
echo "Current directory: $(pwd)"
echo "Listing files and directories:"
ls -la
# Set a default static directory if not using absolute path
STATIC_DIR=${STATIC_DIR:-/app/static}
# Create static directory if it doesn't exist
mkdir -p "$STATIC_DIR"
echo "Created static directory: $STATIC_DIR"
# Check if we have a static directory in the current location
if [ -d "static" ]; then
  echo "Found local static directory, copying to $STATIC_DIR"
  cp -r static/* "$STATIC_DIR/" || echo "Warning: No files to copy from static/"
fi
# If static directory is empty, create a minimal index.html
if [ -z "$(ls -A "$STATIC_DIR")" ]; then
  echo "Static directory is empty, creating minimal index.html"
  echo '<html><head><title>Todo Sorter</title></head><body><h1>Todo Sorter API</h1><p>Frontend not found. Please check your deployment configuration.</p></body></html>' > "$STATIC_DIR/index.html"
fi
# Railway networking startup delay - give internal services time to be fully available
echo "Waiting for 10 seconds to allow network services to fully initialize..."
sleep 10
# Inspect environment
echo "Current Railway environment:"
echo "RAILWAY_ENVIRONMENT: ${RAILWAY_ENVIRONMENT:-not set}"
echo "RAILWAY_PROJECT_ID: ${RAILWAY_PROJECT_ID:-not set}"
echo "RAILWAY_SERVICE_ID: ${RAILWAY_SERVICE_ID:-not set}"
# Check for linked database details
echo "PostgreSQL environment variables:"
echo "PGUSER: ${PGUSER:-not set}"
echo "PGHOST: ${PGHOST:-not set}"
echo "PGPORT: ${PGPORT:-not set}"
echo "PGDATABASE: ${PGDATABASE:-not set}"
echo "PGPASSWORD is ${PGPASSWORD:+set}"
# Explicitly build DATABASE_URL for Railway's internal network
if [ -n "$PGUSER" ] && [ -n "$PGPASSWORD" ] && [ -n "$PGHOST" ] && [ -n "$PGPORT" ] && [ -n "$PGDATABASE" ]; then
  echo "Building DATABASE_URL from PostgreSQL component variables"
  echo "Using Railway internal network: PGHOST=$PGHOST, PGPORT=$PGPORT, PGDATABASE=$PGDATABASE"
  # Create a precise connection string optimized for Railway internal network
  export DATABASE_URL="postgresql://${PGUSER}:${PGPASSWORD}@${PGHOST}:${PGPORT}/${PGDATABASE}?connect_timeout=30&application_name=todo-sorter"
  echo "DATABASE_URL set from component parts (credentials hidden)"
  # Ensure SQLX_OFFLINE is disabled
  export SQLX_OFFLINE=false
  echo "SQLX_OFFLINE=false (allowing live database connections)"
  # Force connection parameters - these will override DATABASE_URL in our application code
  export PG_FORCE_DIRECT_CONNECTION=true
  echo "PG_FORCE_DIRECT_CONNECTION=true (prioritizing direct PG* variables)"
fi
# Check for linked PostgreSQL database via Railway service linking
if [ -n "$DATABASE_URL" ]; then
  echo "Using DATABASE_URL environment variable"
  # Make sure SQLX_OFFLINE is disabled since we have a real database URL
  export SQLX_OFFLINE=false
else
  echo "WARNING: No database connection found. Application will run in memory-only mode."
  echo "Data will not be persisted across restarts."
  export SQLX_OFFLINE=true
fi
# Network connectivity debugging
if [ -n "$DATABASE_URL" ]; then
  # Extract host and port from the connection string
  if [[ "$DATABASE_URL" =~ .*@([^:]+):([0-9]+)/?.* ]]; then
    DB_HOST="${BASH_REMATCH[1]}"
    DB_PORT="${BASH_REMATCH[2]}"
    echo "Database configured at $DB_HOST:$DB_PORT"
    # Check DNS resolution first - this is the most critical for Railway's internal network
    if command -v getent &> /dev/null; then
      echo "Checking hostname resolution with getent..."
      getent hosts "$DB_HOST" || {
        echo "WARNING: Failed to resolve database hostname with getent. This is required for Railway's internal network to work."
        echo "This suggests a networking issue between services. Check that services are in the same Railway project/environment."
      }
    else
      echo "getent not available, using other methods for DNS resolution..."
      # Try to ping the host if we have ping
      if command -v ping &> /dev/null; then
        echo "Checking if database host is reachable via ping..."
        ping -c 1 "$DB_HOST" || echo "WARNING: Could not ping database host. This might be normal if ICMP is blocked."
      fi
      # Check DNS resolution with nslookup if available
      if command -v nslookup &> /dev/null; then
        echo "Checking DNS resolution for database host with nslookup..."
        nslookup "$DB_HOST" || echo "WARNING: Could not resolve database hostname with nslookup."
      fi
    fi
    # Check raw TCP connection with timeout
    if command -v nc &> /dev/null; then
      echo "Testing TCP connection to PostgreSQL..."
      timeout 5 nc -vz "$DB_HOST" "$DB_PORT" || echo "WARNING: Could not establish TCP connection to PostgreSQL."
    elif command -v telnet &> /dev/null; then
      echo "Testing TCP connection with telnet..."
      echo quit | timeout 5 telnet "$DB_HOST" "$DB_PORT" || echo "WARNING: Could not establish TCP connection to PostgreSQL with telnet."
    else
      echo "Neither nc nor telnet commands available for TCP testing."
    fi
    # Try running psql for direct connection test if available
    if command -v psql &> /dev/null; then
      echo "Testing direct PostgreSQL connection with psql..."
      PGCONNECT_TIMEOUT=5 psql -c "SELECT 1;" || echo "WARNING: Could not connect to PostgreSQL with psql."
    fi
    # Give the database a little more time to be fully ready
    echo "Waiting an additional 5 seconds for database to be fully ready..."
    sleep 5
  else
    echo "Could not parse database host and port from DATABASE_URL."
    # Print just the protocol and host part of the URL (hide credentials)
    if [[ "$DATABASE_URL" =~ (postgresql://)[^@]+@([^/]+) ]]; then
      echo "DATABASE_URL format: ${BASH_REMATCH[1]}******@${BASH_REMATCH[2]}"
    else
      echo "DATABASE_URL has unexpected format"
    fi
  fi
fi
# Make the sorter binary executable if needed
chmod +x ./target/release/sorter 2>/dev/null || true
# Check if we need to use target/release or direct executable
if [ -f "./target/release/sorter" ]; then
  echo "Found sorter in target/release"
  SORTER_BIN="./target/release/sorter"
elif [ -f "./sorter" ]; then
  echo "Found sorter in current directory"
  SORTER_BIN="./sorter"
else
  echo "ERROR: Could not find sorter binary"
  exit 1
fi
# Print environment variables for debugging
echo "Environment variables:"
echo "PORT=${PORT}"
echo "STATIC_DIR=${STATIC_DIR}"
echo "SQLX_OFFLINE=${SQLX_OFFLINE}"
echo "DATABASE_URL format: $(echo $DATABASE_URL | sed -E 's/(postgresql:\/\/)[^@]+@/\1****@/')"
echo "PGUSER=${PGUSER:-not set}"
echo "PGHOST=${PGHOST:-not set}"
echo "PGPORT=${PGPORT:-not set}"
echo "PGDATABASE=${PGDATABASE:-not set}"
echo "PGPASSWORD is ${PGPASSWORD:+set}"
echo "RAILWAY_ENVIRONMENT=${RAILWAY_ENVIRONMENT:-not set}"
echo "RAILWAY_PROJECT_ID=${RAILWAY_PROJECT_ID:-not set}"
# Start the application
echo "Starting Todo Sorter API..."
echo "Using static directory: $STATIC_DIR"
STATIC_DIR="$STATIC_DIR" $SORTER_BIN api
</file>

<file path="nixpacks.toml">
[phases.setup]
nixPkgs = ["gcc", "binutils", "openssl", "pkg-config", "nodejs-18_x", "yarn"]

[phases.build]
cmds = [
  "pwd && ls -la",
  "mkdir -p static",
  "cd web && yarn install && yarn build && echo 'Web build complete' && cd ..",
  "cp -r web/dist/* static/ || echo 'Failed to copy web/dist, creating fallback'",
  "[ -z \"$(ls -A static)\" ] && echo '<html><head><title>Todo Sorter</title></head><body><h1>Todo Sorter API</h1></body></html>' > static/index.html || echo 'Static files exist'",
  "ls -la static/",
  "SQLX_OFFLINE=true cargo build --release"
]

[start]
cmd = "./start.sh"
</file>

<file path="Dockerfile">
FROM debian:bullseye-slim as builder

# Install dependencies
RUN apt-get update && \
    apt-get install -y curl ca-certificates pkg-config libssl-dev gnupg build-essential python3 make g++ && \
    curl -fsSL https://deb.nodesource.com/setup_18.x | bash - && \
    apt-get install -y nodejs && \
    npm install -g yarn && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Install rustup and Rust 1.82
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain 1.82.0 && \
    echo 'source $HOME/.cargo/env' >> $HOME/.bashrc

# Add cargo to path
ENV PATH="/root/.cargo/bin:${PATH}"

# Set the working directory
WORKDIR /app

# Copy the entire project
COPY . .

# Build the web frontend
WORKDIR /app/web
RUN yarn install
RUN yarn build
RUN rm -f package-lock.json

# Go back to the app directory and build the Rust application
WORKDIR /app

# Create static directory from web/dist
RUN mkdir -p static && cp -r web/dist/* static/ || echo "Failed to copy web files" && \
    if [ -z "$(ls -A static)" ]; then \
        echo '<html><head><title>Todo Sorter</title></head><body><h1>Todo Sorter API</h1></body></html>' > static/index.html; \
    fi

# Make start.sh executable
RUN chmod +x start.sh

# Enable SQLx offline mode
ENV SQLX_OFFLINE=true

# Build the application
RUN RUSTFLAGS="-C target-cpu=generic" cargo build --release

# Set up the runtime container
FROM debian:bullseye-slim

# Install runtime dependencies
RUN apt-get update && \
    apt-get install -y ca-certificates libssl-dev && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Create app directory
WORKDIR /app

# Copy the built artifacts
COPY --from=builder /app/target/release/sorter /app/sorter
COPY --from=builder /app/static /app/static
COPY --from=builder /app/migrations /app/migrations
COPY --from=builder /app/.sqlx /app/.sqlx
COPY --from=builder /app/start.sh /app/start.sh

# Make start.sh executable
RUN chmod +x /app/start.sh

# Set environment variables
ENV PORT=3000
ENV STATIC_DIR=/app/static
ENV SQLX_OFFLINE=true

# Expose the port
EXPOSE 3000

# Run the application using our start script
CMD ["/app/start.sh"]
</file>

<file path="railway.json">
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "numReplicas": 1,
    "startCommand": "./start.sh",
    "healthcheckPath": "/api/health",
    "healthcheckTimeout": 100,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 3
  },
  "variables": {
    "SQLX_OFFLINE": "false",
    "STATIC_DIR": "/app/static",
    "PG_FORCE_DIRECT_CONNECTION": "true"
  },
  "services": [
    {
      "name": "web",
      "healthcheck": {
        "path": "/api/health",
        "interval": "10s",
        "timeout": "5s",
        "retries": 3
      },
      "port": 3000,
      "linking": {
        "postgres": {
          "service": "Postgres-ozqr",
          "type": "postgres"
        }
      }
    }
  ],
  "plugins": {
    "postgresql": {
      "version": "16"
    }
  }
}
</file>

</files>
